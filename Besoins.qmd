# Besoins (exigences) {#sec-besoins}

Dans le développement de logiciels, il est normal de spécifier ce que le logiciel est censé faire.
Selon la méthodologie proposée dans ce manuel, la spécification des besoins n'est pas facultative!
La spécification des besoins est la base de la méthodologie de développement.

D'abord, qu'est-ce qu'une exigence?
C'est une condition documentée à laquelle un logiciel (ou un système) doit satisfaire.
C'est quelque chose qui facilite la vie d'un utilisateur ou qui amène une valeur socioéconomique.

Voici un exemple d'une exigence d'un système de messagerie instantanée (comme Discord ou Slack): 

::: {.callout}
Il doit permettre à des utilisateurs d'écrire des messages qui seront affichés dans un canal. 
:::

Cette fonctionnalité a une utilité évidente: la communication.
Il s'agit d'une *exigence de fonctionnalité*.

Si ces messages doivent être visibles à toutes les personnes dans le canal en moins de 0,5 seconde, alors il s'agit d'une exigence sur *la qualité de la performance* du système.
Lorsqu'il s'agit des qualités d'un système comme la performance, on peut les appeler *exigences non fonctionnelles*, car elles ne sont pas des fonctionnalités.
Il y a beaucoup d'exemples d'exigences non fonctionnelles, par exemple sur [Wikipedia](https://en.wikipedia.org/wiki/Non-functional_requirement#Examples)\ {{< fa brands wikipedia-w >}}.
Le nom porte à confusion, car une chose qui ne fonctionne pas est "non fonctionnelle".
Pour cette raison, elles sont aussi appelées des exigences sur les qualités ou sur les contraintes.
On peut aussi les appeler informellement les "ilités", car ces qualités sont souvent des aptitudes du système: la maintenabilité, la convivialité, la testabilité, etc.

![Ramasser les besoins non fonctionnels? "[Dog Clean Up](https://thenounproject.com/icon/dog-clean-up-21489/)" de [Luis Prado](https://thenounproject.com/Luis), utilisé selon [CC0](https://creativecommons.org/publicdomain/zero/1.0/)](images/Pick-up-after-dog-1540480672.svg){#fig-besoins width="50%"}

## FURPS+

FURPS+ est un modèle pour classer les exigences (besoins) d'un logiciel. FURPS+ est un acronyme pour Functionality, Usability, Reliability, Performance, Supportability et "+" (autres qualités). Voici un résumé de FURPS+ [voir @craig_uml_2005, section 5.4\ {{< fa solid book >}}]:

- **Fonctionnalité** (*Functionality*). Ce sont les exigences exprimées souvent par les cas d'utilisation, par exemple *Traiter une vente*. La sécurité est aussi considérée dans ce volet.
- **Aptitude à l'utilisation** (*Usability*). Convivialité: les facteurs humains du logiciel, par exemple le nombre de clics que ça prend pour réaliser une fonctionnalité, à quel point une interface est facile à comprendre par une personne, etc.
- **Fiabilité** (*Reliability*). Comment le logiciel doit se comporter lorsqu'il y a des problèmes ou des pannes. 
Par exemple, un logiciel de traitement de texte produit un fichier de sauvegarde de secours, ou une application continue à fonctionner même hors connexion (si le réseau Internet est coupé ou désactivé).
- **Performance** (*Performance*). Comment un logiciel doit se comporter lors d'une charge importante sur le système.
Par exemple, lors de la période d'inscription universitaire, le système doit avoir un temps de réponse de moins de 2 secondes.
- **Possibilités de prise en charge** (*Supportability*). Adaptabilité ou maintenabilité: à quel point le logiciel sera facile à modifier face aux changements prévus.
Par exemple, lors d'un changement de lois fiscales, quelles caractéristiques de la conception vont faciliter le développement d'une nouvelle version du logiciel.
- **"\+"**: Comprend toutes les autres choses:
  - **Implémentation**. Par exemple, le projet doit être réalisé avec des bibliothèques et des langages qui ne sont pas payants (logiciel libre).
  - **Interface**. Par exemple, les contraintes d'interfaçage avec un système externe.
  - **Exploitation**. Par exemple, l'utilisation d'un système d'intégration continue.
  - **Aspects juridiques**. Par exemple, la licence du logiciel, les politiques de confidentialité et d'utilisation des données personnelles, etc.

## La norme ISO 25010:2023

Bien que le modèle FURPS+ proposé en 1992 puisse être encore utilisé aujourd'hui, il existe dorénavant une suite de normes publiée par l'Organisation internationale de normalisation (ISO) afin de fournir un cadre cohérent pour spécifier et évaluer différentes caractéristiques de qualité des logiciels. C'est la suite de normes [ISO/IEC 25000](https://www.iso.org/obp/ui/fr/#iso:std:iso-iec:25000:ed-2:v1:en), aussi connue sous le nom de SQuaRE (Software product Quality Requirements and Evaluation).

La norme [ISO 25010:2023](https://www.iso.org/obp/ui/#iso:std:iso-iec:25010:ed-2:v1:en) vient définir un modèle de qualité logicielle en spécifiant neuf caractéristiques de qualité et des sous-caractéristiques associées, ainsi que des critères d'évaluation pour chaque sous-caractéristique. Les caractéristiques de qualité définies par ISO/IEC 25010:2023 sont :

- **Adéquation fonctionnelle** (*Functional suitability*). C'est la capacité d'un logiciel à fournir des fonctions qui répondent aux exigences spécifiées et aux attentes des utilisateurs dans des conditions données.
  - **Complétude Fonctionnelle** (*Functional Completeness*). C'est la mesure dans laquelle le logiciel fournit toutes les fonctionnalités attendues et requises par les utilisateurs dans un contexte spécifié. 
  - **Exactitude Fonctionnelle** (*Functional Correctness*). C'est la mesure dans laquelle le logiciel produit les résultats corrects et attendus lors de l'exécution de ses fonctions.
  - **Pertinence Fonctionnelle** (*Functional Appropriateness*). C'est la mesure dans laquelle les fonctionnalités fournies par le logiciel répondent aux besoins spécifiques des utilisateurs, dans le contexte prévu d'utilisation.
- **Efficacité de performance** (*Performance Efficiency*). C'est la mesure dans laquelle le logiciel utilise efficacement ses ressources pour accomplir ses fonctions, tout en répondant aux exigences de performance spécifiées.
  - **Comportement Temporel** (*Time Behavior*). C'est la mesure de la capacité du logiciel à répondre aux exigences de temps spécifiées pour ses opérations et fonctionnalités.
  - **Utilisation des Ressources** (*Resource Utilization*). C'est la mesure la mesure dans laquelle le logiciel utilise efficacement les ressources matérielles et logicielles disponibles, telles que le processeur, la mémoire, le stockage et le réseau, pour exécuter ses opérations de manière optimale.
  - **Capacité** (*Capacity*). C'est la mesure de la capacité d'un logiciel à gérer des volumes de données et des charges de travail spécifiques de manière efficace et à maintenir des performances acceptables.
- **Compatibilité** (*Compatibility*). C'est la mesure de la capacité d'un logiciel à fonctionner de manière efficace et cohérente avec d'autres systèmes, logiciels, matériels ou environnements prévus. 
  - **Coexistence** (*Co-existence*). C'est la mesure de la capacité d'un logiciel à fonctionner de manière harmonieuse et efficace avec d'autres logiciels ou composants dans un même environnement, sans interférences ni conflits.
  - **Interopérabilité** (*Interoperability*). C'est la mesure de la capacité d'un logiciel à fonctionner et à interagir avec d'autres systèmes, logiciels ou composants externes, en échangeant des données et en coopérant efficacement pour réaliser des tâches ou des opérations communes.
- **Capacité d'interaction** (*Interaction capability*). C'est la mesure de la capacité d'un logiciel à interagir de manière efficace et intuitive avec les utilisateurs, en fournissant des interfaces utilisateur conviviales et en facilitant les interactions homme-machine fluides.
  - **Reconnaissabilité** (*Appropriateness Recognizability*). C'est la mesure de la capacité d'un logiciel à permettre aux utilisateurs d'identifier facilement et rapidement les éléments de l'interface utilisateur et à comprendre leur fonction ou leur utilisation.
  - **Facilité d’apprentissage** (*Learnability*). C'est la mesure de la capacité d'un logiciel à permettre aux utilisateurs d'apprendre à l'utiliser rapidement et efficacement, même s'ils sont nouveaux dans son utilisation.
  - **Opérabilité** (*Operability*). C'est la mesure de la capacité d'un logiciel à être facilement exploité, géré et maintenu par les opérateurs et les administrateurs système dans divers environnements d'exploitation. Elle évalue la facilité avec laquelle les professionnels de l'informatique peuvent déployer, configurer, surveiller, diagnostiquer et maintenir le logiciel de manière efficace et efficiente.
  - **Protection contre les erreurs utilisateur** (*User Error Protection*). C'est la mesure de la capacité d'un logiciel à prévenir, détecter et gérer les erreurs commises par les utilisateurs, afin de minimiser les conséquences négatives sur le système et les données. Elle évalue la capacité du logiciel à fournir des mécanismes et des protections pour éviter que les utilisateurs commettent des erreurs, ainsi que pour gérer les erreurs qui surviennent pour limiter leur impact.
  - **Engagement des utilisateurs** (*user engagement*). C'est la mesure dans laquelle un logiciel parvient à captiver et à maintenir l'intérêt des utilisateurs, en les encourageant à utiliser activement le logiciel de manière régulière et continue. Elle évalue la capacité du logiciel à offrir une expérience utilisateur attrayante et gratifiante, qui motive les utilisateurs à explorer les fonctionnalités du logiciel, à interagir avec celui-ci et à y revenir fréquemment. Cela inclut la convivialité de l'interface utilisateur, la qualité du contenu, la personnalisation des fonctionnalités, et la disponibilité de fonctionnalités sociales ou ludiques.
  - **Inclusivité** (*Inclusivity*). C'est la mesure dans laquelle un logiciel est conçu pour être accessible et utilisable par un large éventail d'utilisateurs, y compris ceux ayant des besoins spécifiques ou des limitations physiques, sensorielles, cognitives ou linguistiques. Elle évalue la capacité du logiciel à prendre en compte la diversité des utilisateurs et à offrir une expérience utilisateur équitable et satisfaisante pour tous, sans exclure ni discriminer aucun utilisateur en raison de ses caractéristiques personnelles ou de ses capacités.
  - **Aide aux utilisateurs** (*User assistance*). C'est la mesure de la capacité d'un logiciel à fournir un soutien et du soutien aux utilisateurs afin de les aider à comprendre, à utiliser et à résoudre les problèmes liés à l'utilisation du logiciel de manière efficace et autonome. Cela peut inclure des fonctionnalités telles que des interfaces utilisateur adaptables, des options de personnalisation, des aides à la navigation, des outils d'assistance et d'autres dispositifs destinés à répondre aux besoins variés des utilisateurs comme des différences linguistiques, des handicaps physiques ou sensoriels, de l'âge et d'autres facteurs qui peuvent influencer l'accessibilité et l'utilisabilité du logiciel.
  - **Auto-description** (*Self-descriptiveness*). C'est la mesure de la capacité d'un logiciel à fournir des informations claires et explicites sur son fonctionnement, ses fonctionnalités et son utilisation, sans nécessiter de connaissances externes ou d'informations supplémentaires pour les utilisateurs. Elle évalue dans quelle mesure le logiciel est capable de se décrire lui-même de manière compréhensible et intuitive, en fournissant des indications, des messages d'aide, des instructions et des descriptions qui permettent aux utilisateurs de comprendre facilement comment utiliser le logiciel et d'interagir avec celui-ci de manière efficace.
- **Fiabilité** (*Reliability*). C'est la mesure de la capacité d'un logiciel à maintenir un niveau de performance spécifié dans des conditions d'utilisation données et pendant une période définie. Elle évalue la capacité du logiciel à fonctionner de manière stable et cohérente, en minimisant les risques de défaillance, de panne ou de comportement imprévu. 
  - **Irréprochabilité** (*Faultlessness*). C'est la mesure de la capacité d'un logiciel à fonctionner sans présenter de défauts ou d'erreurs dans son fonctionnement. Elle évalue la qualité du logiciel à exécuter ses fonctions sans causer d'anomalies, de pannes ou de dysfonctionnements.
  - **Disponibilité** (*Availability*). C'est la mesure de la capacité d'un logiciel à être utilisable et accessible, lorsque requis, en garantissant que ses fonctionnalités sont disponibles pour les utilisateurs selon les besoins convenus. Elle évalue la capacité du logiciel à être opérationnel et accessible pendant une période déterminée, en minimisant les temps d'arrêt et en assurant une continuité de service. 
  - **Tolérance aux erreurs** (*Fault Tolerance*). C'est la mesure de la capacité d'un logiciel à maintenir un niveau de performance acceptable malgré la présence d'erreurs ou de défaillances dans son fonctionnement. Elle évalue la capacité du logiciel à détecter, à isoler et à gérer les erreurs ou les pannes de manière à limiter leur impact sur le système dans son ensemble.
  - **Récupérabilité** (*Recoverability*). C'est la mesure de la capacité d'un logiciel à restaurer un état opérationnel stable et fonctionnel après qu'une erreur ou une défaillance se soit produite.
- **Sécurité** (*Security*). C'est la mesure de la capacité d'un logiciel à protéger les données, les systèmes et les utilisateurs contre les menaces, les attaques et les vulnérabilités potentielles, tout en préservant la confidentialité, l'intégrité et la disponibilité des informations.
  - **Confidentialité** (*Confidentiality*). C'est la mesure de la capacité d'un logiciel à garantir que les informations sensibles sont protégées contre l'accès ou la divulgation non autorisés. Elle évalue la capacité du logiciel à préserver la confidentialité des données en limitant l'accès à ceux qui ont l'autorisation appropriée, en utilisant des mécanismes de cryptage et d'authentification, ainsi qu'en contrôlant les autorisations d'accès.
  - **Intégrité** (*Integrity*). C'est la mesure de la capacité d'un logiciel à garantir que les données sont protégées contre toute altération non autorisée ou non intentionnelle, afin de maintenir leur exactitude, leur cohérence et leur fiabilité. Elle évalue la capacité du logiciel à prévenir les modifications non autorisées des données, à assurer leur authenticité et leur précision, ainsi qu'à détecter et à réagir aux altérations potentielles pour éviter toute altération indésirable.
  - **Non-répudiation** (*Non-repudiation*). C'est la mesure de la capacité d'un système informatique à fournir une preuve fiable de l'origine ou de l'envoi d'une communication, ainsi que de l'authenticité et de l'intégrité des données associées, de manière à ce que cette preuve ne puisse être niée par l'une des parties concernées.
  - **Responsabilité** (*Accountability*). C'est la mesure de la capacité d'un système informatique à attribuer de manière fiable les actions, les décisions et les événements à des entités spécifiques, et à rendre ces entités responsables de leurs actions. Elle évalue la capacité du système à enregistrer et à tracer les activités des utilisateurs et des composants du système, ainsi qu'à fournir des mécanismes de contrôle et de suivi pour déterminer qui a fait quoi, quand et pourquoi. 
  - **Authenticité** (*Authenticity*). C'est la mesure de la capacité d'un système informatique à garantir que les entités, les origines et les ressources impliquées dans une communication ou une transaction sont véritablement ce qu'elles prétendent être. Elle évalue la fiabilité des identités et des sources des données, ainsi que la véracité des informations échangées, afin de prévenir la falsification, la contrefaçon ou la manipulation des données.
  - **Résistance** (*Resistance*). C'est la mesure de la capacité d'un logiciel à résister aux tentatives de compromission de sa sécurité, notamment aux attaques, aux intrusions et aux violations de la confidentialité, de l'intégrité et de la disponibilité des données. Elle évalue la robustesse du logiciel face à diverses menaces et vulnérabilités, ainsi que sa capacité à maintenir un niveau de sécurité adéquat même en présence d'attaques malveillantes ou de tentatives d'exploitation.
- **Maintenabilité** (*Maintainability*). C'est la mesure de la facilité et à l'efficacité avec lesquelles un logiciel peut être modifié, corrigé, amélioré ou adapté dans le cadre de ses opérations de maintenance. Elle évalue la capacité du logiciel à être compris, modifié et réparé facilement, tout en minimisant les coûts, les efforts et les risques associés à ces activités de maintenance.
  - **Modularité** (*Modularity*). C'est la mesure de la capacité d'un système logiciel à être divisé en composants autonomes et interopérables, appelés modules, qui peuvent être développés, testés, maintenus et utilisés de manière indépendante les uns des autres. Elle évalue la facilité avec laquelle un logiciel peut être décomposé en parties plus petites et plus gérables, ce qui permet une meilleure organisation du code, une réutilisation efficace des composants, une simplification du développement et une amélioration de la maintenabilité.
  - **Réutilisabilité** (*Reusability*). C'est la mesure de la capacité des composants logiciels à être utilisés dans plusieurs contextes ou applications sans nécessiter de modifications importantes, tout en conservant leur fonctionnalité et leur performance. Elle évalue la facilité avec laquelle les composants logiciels peuvent être réemployés dans différents projets ou environnements, ce qui permet de réduire les efforts de développement, d'accélérer le processus de développement et d'améliorer la productivité.
  - **Analysabilité** (*Analysability*). C'est la mesure de la facilité avec laquelle un logiciel peut être analysé, évalué et compris par les développeurs, les testeurs et les autres parties prenantes afin d'identifier les problèmes, les besoins d'amélioration et les opportunités d'optimisation. Elle évalue la clarté, la cohérence et la concision du code source, ainsi que la disponibilité d'outils et de techniques d'analyse permettant de faciliter l'inspection, la recherche de bogues et l'optimisation du logiciel.
  - **Modifiabilité** (*Modifiability*). C'est la mesure de la facilité avec laquelle un logiciel peut être modifié, étendu ou adapté pour répondre aux besoins changeants des utilisateurs, des entreprises ou de l'environnement. Elle évalue la capacité du logiciel à être rapidement et efficacement modifié sans compromettre sa qualité, sa stabilité ou sa performance.
  - **Testabilité** (*Testability*). C'est la mesure de la facilité avec laquelle un logiciel peut être testé de manière efficace et approfondie pour évaluer sa qualité, détecter les erreurs et vérifier sa conformité aux exigences fonctionnelles et non fonctionnelles. Elle évalue la capacité du logiciel à être soumis à des tests automatisés ou manuels de manière à garantir une couverture adéquate des fonctionnalités, des cas d'utilisation et des scénarios d'utilisation, ainsi qu'à faciliter la détection et la correction des défauts.
- **Flexibilité** (*Flexibility*). C'est la mesure de la capacité d'un logiciel à être facilement adapté ou configuré pour répondre à des besoins changeants ou à des variations dans les environnements d'utilisation. Elle évalue la capacité du logiciel à supporter des changements dans les exigences fonctionnelles ou non fonctionnelles, ainsi que dans les préférences des utilisateurs, sans nécessiter de modifications majeures de son code source ou de son architecture.
  - **Adaptabilité** (*Adaptability*). C'est la mesure de la capacité d'un logiciel à être modifié ou ajusté de manière appropriée pour s'adapter à des changements dans son environnement opérationnel, tels que de nouvelles exigences, des conditions d'utilisation différentes ou l'évolution des technologies.
  - **Évolutivité** (*Scalability*). C'est la mesure de la capacité d'un système logiciel à maintenir ses performances, sa fiabilité et sa qualité de service lorsqu'il est soumis à une augmentation de la charge de travail ou à une expansion de sa taille, que ce soit en termes de données traitées, de nombre d'utilisateurs ou de volume de transactions.
  - **Installabilité** (*Installability*). C'est la mesure de la facilité avec laquelle un logiciel peut être installé, configuré et désinstallé sur un système informatique cible, de manière à garantir une expérience utilisateur fluide et sans heurts. Elle évalue la convivialité du processus d'installation du logiciel, y compris la clarté des instructions d'installation, la facilité de configuration des paramètres, la compatibilité avec l'environnement système et la gestion des dépendances logicielles.
  - **Remplaçabilité** (*Replaceability*). C'est la mesure de la capacité d'un logiciel à être remplacé par une autre solution de manière transparente, sans perturbation significative pour les utilisateurs ou les processus métier. Elle évalue la facilité avec laquelle un logiciel peut être retiré ou remplacé par une alternative, tout en assurant la continuité des opérations et la préservation des données et des fonctionnalités.
- **Sûreté** (*Safety*). C'est la mesure de la capacité d'un logiciel à garantir que son utilisation ne causera pas de dommages, de blessures ou de conséquences néfastes pour les personnes, les biens matériels ou l'environnement.
  - **Contrainte opérationnelle** (*Operational constraint*). C'est la mesure de la capacité d'un logiciel à limiter son fonctionnement à des paramètres ou états sûrs lorsqu'il rencontre des risques opérationnels. Elle évalue comment un logiciel peut garantir qu'il reste sûr à utiliser même dans des conditions potentiellement dangereuses ou imprévues.
  - **Identification des risques** (*Risk identification*). C'est la mesure de la capacité d'un logiciel à identifier les séquences d'événements ou d'opérations qui pourraient exposer la vie, les biens ou l'environnement à des risques inacceptables.
  - **Sécurité en cas de défaillance** (*Fail safe*). C'est la mesure de la capacité d'un logiciel à se placer automatiquement dans un mode de fonctionnement sûr ou à revenir à un état sécurisé en cas de défaillance. Elle évalue la capacité du logiciel à prendre des mesures appropriées pour minimiser les dommages potentiels en cas de défaillance, en adoptant un comportement sûr ou en mettant en œuvre des mécanismes de sécurité pour prévenir les risques pour les utilisateurs, les biens ou l'environnement.
  - **Avertissement de danger** (*Hazard warning*). C'est la mesure de la capacité d'un logiciel à identifier et à signaler les dangers potentiels ou les situations à risque, permettant aux utilisateurs ou aux systèmes de prendre des mesures préventives pour éviter les dommages ou les conséquences néfastes.
  - **Intégration sécurisée** (*Safe integration*). C'est la mesure de la capacité d'un logiciel à maintenir la sécurité pendant et après son intégration avec un ou plusieurs composants, tels que des modules logiciels, des systèmes tiers ou des périphériques, sans compromettre la sécurité globale du système.