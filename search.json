[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse et conception de logiciels",
    "section": "",
    "text": "Remerciements aux personnes suivantes : Conversion Markdown : Clyde Vianney Omog Ntap, Taki Eddine Seghiri ; Création d’exercices : Olivier Brochu, Clyde Vianney Omog Ntap ; Révision : Katerine Robert ; Relecture : Olivier Brochu, Roberto Erick Lopez-Herrejon, Mouna Moumene, Taki Eddine Seghiri.\nCe manuel a été réalisé avec le soutien de la fabriqueREL. Fondée en 2019, la fabriqueREL est portée par divers établissements d’enseignement supérieur du Québec et agit en collaboration avec les services de soutien pédagogique et les bibliothèques. Son but est de faire des ressources éducatives libres (REL) le matériel privilégié en enseignement supérieur au Québec.\nISBN-13 : 978-2-921145-90-9\nDépôt légal, Bibliothèque et Archives nationales du Québec, 2023.\nDépôt légal, Bibliothèque et Archives Canada, 2023.\n© Christopher Fuhrman et Yvan Ross (2023)\nPour citer ce manuel : Christopher Fuhrman et Yvan Ross. (2023). Analyse et conception de logiciels. École de technologie supérieure. Sous licence CC BY."
  },
  {
    "objectID": "index.html#préface",
    "href": "index.html#préface",
    "title": "Analyse et conception de logiciels",
    "section": "Préface",
    "text": "Préface\nCe manuel a commencé comme notes de cours pour le cours Analyse et conception de logiciels (LOG210) dans les programmes de baccalauréat en génie logiciel (LOG) et en génie des technologies de l’information (GTI) de l’École de technologie supérieure (ÉTS) à Montréal, au Québec. À l’origine, la communauté étudiante dans ces programmes provenait des collèges d’enseignement général et professionnel (cégeps), ayant donc déjà reçu un diplôme d’études collégiales (DEC) dans un programme technique. Ainsi, ces personnes ont déjà appris à programmer dans un langage orienté objet. En effet, cette démarche correspond à l’approche « computer science first » (CS-first) pour enseigner le génie logiciel (Ardis et coll., 2015).\nLOG210 a été mis sur pied au début des années 2000, et le livre obligatoire a toujours été le fameux Applying UML and Patterns de Craig Larman, qui en était à sa 2e édition (2001) à l’époque. En 2005, la 3e édition a été publiée avec plusieurs traductions, notamment celle en français (2005). Pendant plus de dix ans, le livre de Larman a été fort apprécié par la communauté étudiante.\nMais pour le corps enseignant donnant le cours, le manque d’exercices dans le livre a toujours été un gros inconvénient. En plus, certains sujets (comme les cas d’utilisation, les préconditions des contrats d’opération et les diagrammes de communication) dans le livre de Larman sont moins pertinents en industrie aujourd’hui, puis d’autres sujets (comme le développement piloté par les tests, le travail en équipe et les cadriciels Web) sont devenus plus importants. Une 4e édition n’a jamais été publiée. Finalement, la traduction française du livre est en rupture de stock depuis 2019. Le présent manuel essaie de pallier tous ces problèmes, sous forme de ressource éducative libre (REL)."
  },
  {
    "objectID": "index.html#pourquoi-une-ressource-éducative-libre",
    "href": "index.html#pourquoi-une-ressource-éducative-libre",
    "title": "Analyse et conception de logiciels",
    "section": "Pourquoi une ressource éducative libre ?",
    "text": "Pourquoi une ressource éducative libre ?\nAujourd’hui, les logiciels libres sont très répandus. Dans le cadre de l’enseignement, nous utilisons les dépôts de code source libre comme GitHub et GitLab, car ces plateformes permettent d’évaluer et de valider des logiciels ainsi que de collaborer dans les communautés de logiciel libre. Il est donc naturel d’imaginer une forme analogue pour le contenu de ce manuel, soit une ressource éducative libre (REL), qui est également développée à travers un dépôt libre (GitHub dans ce cas).\nPour favoriser la réutilisation, nous avons utilisé plusieurs logiciels libres :\n\nQuarto (2023) (le langage source du texte est Markdown) ;\nPandoc (2022) et LaTeX (2022), et plusieurs filtres de traitement qui font partie des composantes exploitées par Quarto ;\nPlantUML (2022) pour les figures sous forme de texte (faciles à actualiser).\n\nNous soulignons les retombées sur le plan de logiciels libres lors de la rédaction de ce manuel, car il est important de contribuer aux communautés de logiciels libres. Nous avons fourni une rétroaction à des développeurs et développeuses de plusieurs projets utilisés. Par exemple, nous avons identifié plusieurs bogues dans les versions préliminaires de Quarto (qui ont été corrigés rapidement, parfois le lendemain même !) Nous avons même créé de nouveaux projets libres, tels qu’un filtre Pandoc pour faciliter la bonne utilisation d’espaces insécables selon les règles de typographie en français.\nAutant que possible, les figures du manuel sont créées dans une forme vectorielle (comme SVG) plutôt que matricielle (comme JPEG ou PNG) afin que le texte dans les figures soit « indexable » par les moteurs de recherche et aussi accessible aux personnes non-voyantes.\nFinalement, il y a une tendance à faire des REL pour favoriser l’accès à l’information et pour permettre une meilleure inclusivité des personnes apprenantes et enseignantes. Nous avons donc essayé de suivre les directives du Guide de l’écriture inclusive de l’ÉTS lors de la rédaction de ce manuel."
  },
  {
    "objectID": "index.html#prérequis",
    "href": "index.html#prérequis",
    "title": "Analyse et conception de logiciels",
    "section": "Prérequis",
    "text": "Prérequis\nLe contenu de ce manuel est organisé pour les personnes ayant déjà une base et une expérience avec :\n\nla programmation dans un langage orienté objet (Java, C#, C++, Python, TypeScript, etc.) ;\nles concepts de modélisation orientée objet (les classes, les interfaces, les instances, l’héritage, la composition, le polymorphisme, etc.) ;\nles tests unitaires (avec un cadriciel comme JUnit) ;\nl’application des patterns de la « Bande des quatre » (Gang of Four ou GoF) : Gamma, Helm, Johnson, et Vlissides (1994).\n\nLa notation UML (Unified Modeling Language) est utilisée partout dans ce manuel. Nous faisons l’hypothèse que les personnes suivant ce manuel ont déjà vu cette notation avant, mais la familiarité avec l’UML n’est pas un préalable."
  },
  {
    "objectID": "index.html#livre-complémentaire",
    "href": "index.html#livre-complémentaire",
    "title": "Analyse et conception de logiciels",
    "section": "Livre complémentaire",
    "text": "Livre complémentaire\nCe manuel suit la méthodologie d’analyse et de conception proposée par Craig Larman dans son livre UML 2 et les design patterns (Larman, 2005). Le livre est encore populaire et pertinent, mais, malheureusement, il n’a pas été actualisé depuis sa 3e édition (en 2005). De plus, la traduction française du livre n’est plus en stock au Québec depuis plusieurs années, et beaucoup de choses ont évolué depuis bientôt vingt ans !\n\n\n\n\n\n\nNote\n\n\n\nAu besoin, des références au livre de Larman sont indiquées par l’icône du livre . Puisqu’il est disponible en français et en anglais, et qu’il y a des différences avec les numéros de chapitres, nous indiquons une référence avec F et A pour signifier la langue du livre. Par exemple, la matière sur les principes GRASP est dans le chapitre 17 dans la version en anglais. Cependant, à cause des fusions de contenu lors de la traduction, la matière sur GRASP est dans le chapitre 16 dans la version en français. Dans ce cas, à cause des différences de chapitres, F16.10/A17.10 indique la section 16.10 du livre en français et la section 17.10 du livre en anglais. Toutes les références sont données pour la 3e édition du livre.\n\n\n\n\n\n\n\n\nMise en garde\n\n\n\nSi vous avez une autre édition, comme la 2e du livre en anglais ou même une des premières impressions de la 3e du livre en anglais, les chapitres ne sont pas toujours les mêmes, et vous devrez chercher le sujet dans la table des matières.\n\n\nCependant, dans ce manuel, vous trouverez également d’autres sujets importants pour une personne qui étudie en génie : les notions de complexité, le contexte industriel qui affecte les décisions de conception, l’impact de la conception sur d’autres qualités d’un logiciel, le travail en équipe, etc."
  },
  {
    "objectID": "index.html#sources-du-manuel",
    "href": "index.html#sources-du-manuel",
    "title": "Analyse et conception de logiciels",
    "section": "Sources du manuel",
    "text": "Sources du manuel\nCe manuel est écrit en Markdown, et le code source est sur GitHub à https://github.com/fuhrmanator/log210-ndc-quarto. Les versions Web, PDF et EPUB ont été générées par le logiciel Quarto. Pour en savoir plus sur Quarto, visitez https://quarto.org/docs/books.\n\n\n\n\n\nArdis, M., Hislop, G., Sebern, M., Budgen, D., Offutt, J., et Visser, W. (2015). Software Engineering 2014 - Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering. ACM: Association for Computing Machinery.\n\n\nGamma, E., Helm, R., Johnson, R., et Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software (1ʳᵉ éd.). Reading, Mass : Addison-Wesley Professional. Repéré à http://amazon.com/o/ASIN/0201633612/\n\n\nLarman, C. (2001). Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and the Unified Process (2nd edition). Upper Saddle River, NJ : Prentice Hall.\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial.\n\n\nLaTeX. (2022). Dans Wikipedia. Repéré à https://en.wikipedia.org/w/index.php?title=LaTeX&oldid=1114993597\n\n\nPandoc. (2022). Dans Wikipedia. Repéré à https://en.wikipedia.org/w/index.php?title=Pandoc&oldid=1116852485\n\n\nPlantUML. (2022). Dans Wikipedia. Repéré à https://en.wikipedia.org/w/index.php?title=PlantUML&oldid=1111009429\n\n\nQuarto. (2023, 14 février). Repéré à https://quarto.org/"
  },
  {
    "objectID": "AnalyseConception.html#analyse-vs-conception",
    "href": "AnalyseConception.html#analyse-vs-conception",
    "title": "1  Analyse et conception de logiciels",
    "section": "1.1 Analyse vs Conception",
    "text": "1.1 Analyse vs Conception\nL’analyse met l’accent sur une investigation du problème et des besoins plutôt que sur la recherche d’une solution.\nLa conception sous-entend l’élaboration d’une solution conceptuelle répondant aux besoins plutôt que la mise en œuvre de cette solution.\n\n\n\nJoueurnom : StringnbLancers : intnbLancersGagnés : intDéface : intJeuDeDésinclut12joue1*\nFigure 1.1: Diagramme de classes conceptuelles décrivant (modélisant) le problème d’un jeu de dés (figure 1.3 ) avec des statistiques. Ceci est élaboré lors d’une activité d’analyse.\n\n\n\n\nDéface : intbrasser()JeuDeDésgetJoueurs()démarrerJeu(nom : string)jouer(nom : string)terminerJeu(nom : string)Joueurnom : stringnbLancers : numbernbLancersGagnés : numberd1d2        [nom]\nFigure 1.2: Diagramme de classes logicielles décrivant une solution au problème du jeu de dés. La conception s’inspire du modèle du problème, afin de faciliter sa compréhension.\n\n\nImaginez que l’on veut construire un logiciel pour un jeu de dés, un jeu qui est joué dans la vraie vie avec deux dés à six faces. Comment procéder ? On peut spécifier la règle du jeu, dont un des nombreux besoins est de générer un nombre aléatoire entre 1 et 6 (comme un numéro qui apparaît sur l’une des six faces du dé). On peut aussi modéliser ce besoin (un élément du problème) par une classe conceptuelle Dé ayant un attribut face dont la valeur est un type int. Les personnes travaillant sur le projet vont facilement comprendre ce modèle, car les gens comprennent les objets qui représentent des aspects de la vraie vie.\nDans l’approche proposée par ce manuel, une modélisation orientée objet est utilisée et pour l’analyse (classes conceptuelles décrivant le problème et les besoins comme à la figure 1.1) et pour la conception (classes logicielles proposant une solution dont la représentation est proche de la modélisation du problème comme à la figure 1.2)."
  },
  {
    "objectID": "AnalyseConception.html#sec-DecalageRepresentations",
    "href": "AnalyseConception.html#sec-DecalageRepresentations",
    "title": "1  Analyse et conception de logiciels",
    "section": "1.2 Décalage des représentations",
    "text": "1.2 Décalage des représentations\nVous avez sûrement remarqué que le modèle du problème (figure 1.1) ressemble beaucoup au modèle de la solution (figure 1.2) pour notre exemple de jeu de dés. Cependant, il y a des différences, car une solution comporte des détails sur la dynamique du jeu qui sera codée. Le modèle du problème et le modèle de la solution ne sont donc pas identiques.\n\n\n\n\n\n\nImaginez une autre solution n’ayant qu’une seule classe Jeu contenant toute la logique du jeu. Avez-vous déjà codé une solution simple comme ça ? C’est un bon design au départ, car il est simple. Mais au fur et à mesure que vous codez la logique du jeu, bien que ça fonctionne parfaitement, la classe Jeu grossit et devient difficile à comprendre. \n\n\n\nUne caractéristique souhaitable d’un design est qu’il soit facile à comprendre et à valider par rapport au problème qu’il est censé résoudre.  Plus une solution (conception) ressemble à une description (modèle d’analyse) du problème, plus elle est facile à comprendre et à valider. La différence entre la représentation d’un problème et la représentation de sa solution s’appelle le décalage des représentations. C’est un terme complexe pour un principe très intuitif. Méfiez-vous des classes importantes dont le nom retrace difficilement le problème. Elles vont rendre votre solution plus difficile à comprendre. Pour des explications de Larman, lisez la section 9.3 .\nL’exemple du jeu est trivial, puisque le problème est relativement simple. Réduire le décalage des représentations est un principe très important, surtout lorsque le problème à résoudre est complexe."
  },
  {
    "objectID": "AnalyseConception.html#la-complexité-et-ses-sources",
    "href": "AnalyseConception.html#la-complexité-et-ses-sources",
    "title": "1  Analyse et conception de logiciels",
    "section": "1.3 La complexité et ses sources",
    "text": "1.3 La complexité et ses sources\nLes ingénieures logiciel et ingénieurs logiciel sont constamment dans une bataille avec une adversaire dont le nom est la « complexité ». Mais qu’est-ce que la complexité ? La figure 1.3 est une image de la complexité. Reconnaissez-vous le domaine d’où vient cette image ?\nVoici une définition de la complexité.\n\n\n\n\n\n\nComplexité : Caractère de ce qui est complexe, difficile à comprendre, de ce qui contient plusieurs éléments.\n\n\n\n\n\n\nFigure 1.3: « Complexity » (CC BY-SA 2.0) par lytfyre.\n\n\nEn voici quelques exemples en développement de logiciels :\n\nUn problème peut être complexe, par exemple le domaine des lois fiscales pour lequel des logiciels existent pour aider les gens à faire des déclarations de revenus.\nUn projet logiciel peut être complexe, avec plusieurs packages, chacun ayant beaucoup de classes, etc.\nUn cadre d’applications (cadriciel, framework) est toujours complexe, par exemple un framework comme Angular ou React pour développer un front-end (application frontale), car l’interaction entre l’utilisateur et une application (possiblement répartie dans le nuage) nécessite beaucoup de fonctionnalités supportées par le cadriciel.\nUn algorithme peut être complexe, par exemple l’algorithme de tri de Shell est plus complexe qu’un simple algorithme de tri à bulles. Notez que la complexité d’un algorithme peut parfois apporter des gains de performance, par exemple le tri de Shell. Mais le codage, le débogage et la maintenance d’une implémentation d’un algorithme complexe seront plus coûteux.\nUn pattern de conception peut être complexe, par exemple les patterns Visiteur, Décorateur, Médiateur, etc., de Gamma, Helm, Johnson, et Vlissides (1994). Un pattern définit des rôles et parfois du code et des classes supplémentaires à créer. Le tout doit s’intégrer dans un design existant (qui a son propre niveau de complexité).\nUn environnement peut être complexe, par exemple les applications mobiles sont plus complexes à développer et à déboguer que les applications simples sur PC, à cause de l’environnement sans fil, des écrans tactiles de tailles différentes, de l’alimentation limitée, etc.\n\nLa figure 1.4 présente les sources de complexité ainsi que leurs noms, qu’on va utiliser dans ce manuel.\n\n1.3.1 Complexité inhérente (provenant du problème)\nLa complexité inhérente est au sein du problème que résout un logiciel. Elle est souvent visible à l’utilisateur du logiciel. Elle se compose des parties du logiciel qui sont nécessairement des problèmes difficiles. N’importe quel logiciel qui tente de résoudre ces problèmes aura une manifestation de cette complexité dans son implémentation. Exemple : un logiciel qui aide à faire des déclarations de revenus aura une complexité inhérente due à la complexité des lois fiscales qui spécifient comment doit être préparée une déclaration.\n\n\n1.3.2 Complexité circonstancielle (provenant des choix de conception)\nLes choix que font les ingénieures et ingénieurs dans un projet peuvent amener de la complexité circonstancielle (aussi appelée accidentelle). En tant qu’ingénieures et ingénieurs, nous avons un devoir de contrôler cette forme de complexité, par exemple en choisissant soigneusement un cadriciel Web ou une architecture logicielle. La complexité circonstancielle peut aussi être due à des contraintes imposées sur la conception, comme l’utilisation obligatoire d’une vieille base de données ou d’une bibliothèque logicielle héritée, d’un langage de programmation, etc. La complexité circonstancielle peut être gérée avec des technologies, par exemple les débogueurs, les patterns GoF (un Adaptateur pour les différentes bases de données), etc.\n\n\n1.3.3 Complexité environnementale (provenant de l’environnement d’exécution)\nCette forme de complexité comprend des aspects d’une solution qui ne sont pas sous le contrôle des ingénieures et ingénieurs. Dans un environnement d’exécution, il y a des dimensions comme le ramasse-miettes (garbage collection), l’ordonnancement des fils d’exécution (threads) sur un serveur, l’utilisation de conteneurs (à la Docker), etc. qui peuvent affecter la qualité d’un logiciel. Les ingénieures et ingénieurs doivent gérer ces formes de complexité, mais il n’y a pas beaucoup de stratégies évidentes face aux technologies qui évoluent à grande vitesse.\n\n\nDomaine (du problème)Conception logicielleSolution exécutableComplexitéinhérenteSpécification d'exigencesComplexitécirconstancielleComplexitéenvironnementaleExemple :Lois fiscales (impôts)Exemples :FrameworkREST,utilisation du pattern Visiteur,intégration avec un logiciel légataireExemples :Application mobile,déploiement dans conteneur Docker\nFigure 1.4: Sources de complexité (inhérente, circonstancielle et environnementale) par rapport au processus de développement (analyse, conception et implémentation)."
  },
  {
    "objectID": "AnalyseConception.html#survol-de-la-méthodologie",
    "href": "AnalyseConception.html#survol-de-la-méthodologie",
    "title": "1  Analyse et conception de logiciels",
    "section": "1.4 Survol de la méthodologie",
    "text": "1.4 Survol de la méthodologie\nLa méthodologie d’analyse et de conception proposée dans ce manuel se base sur celle présentée par Larman (2005).\nVoici les éléments importants documentés dans ce manuel (voir la figure 1.5) :\n\nIl y a une spécification explicite des besoins (Chapitre 2) dans le modèle de cas d’utilisation ;\nÀ partir de chaque cas d’utilisation (Chapitre 3), il y a une conception de haut niveau (l’interface API du système à développer) documentée sous forme de diagramme de séquence système (DSS) (Chapitre 5) ;\nÀ partir de chaque DSS, on peut définir un ensemble de contrats d’opération (Chapitre 8), surtout pour les opérations complexes ;\nÀ partir de l’ensemble des besoins, on construit un modèle du domaine (MDD) (Chapitre 4) ;\nPour faire une conception intuitive et facile à adapter, on propose un modèle de conception sous forme de plusieurs réalisations de cas d’utilisation (RDCU) (Chapitre 9) qui sont cohérentes avec le MDD (pour diminuer le décalage des représentations) et avec les contrats ;\nPour implémenter les conceptions, on développe du code à partir des diagrammes dans le modèle de conception, ainsi que du code pour tester tout ça selon le développement piloté par les tests (Chapitre 10) ;\nPour gérer la dette technique (Chapitre 7) on fait du réusinage (Chapitre 11) au besoin ;\nLe tout se fait de manière évolutive, en itérations courtes selon le processus unifié.\n\n\n\n\nFigure 1.5: Survol des parties de la méthodologie de Larman (2005) utilisées dans ce manuel."
  },
  {
    "objectID": "AnalyseConception.html#développement-itératif-évolutif-et-agile",
    "href": "AnalyseConception.html#développement-itératif-évolutif-et-agile",
    "title": "1  Analyse et conception de logiciels",
    "section": "1.5 Développement itératif, évolutif et agile",
    "text": "1.5 Développement itératif, évolutif et agile\nNous adoptons également un processus moderne de développement avec des itérations, selon une méthodologie « agile ». Dans le chapitre 2 , on définit le processus itératif et adaptatif ainsi que les concepts fondamentaux du « processus unifié », qui est une représentation générique de cette stratégie de développement.\nNous résumons les points importants ainsi :\n\nLe développement itératif et évolutif implique de programmer et de tester précocement un système partiel dans des cycles répétitifs.\nUn cycle est nommé une itération et dure un temps fixe (par exemple trois semaines) comprenant les activités d’analyse, de conception, de programmation et de test, ainsi qu’une démonstration pour solliciter des rétroactions du client (voir la figure 1.7).\nLa durée d’une itération est limitée dans le temps (timeboxed en anglais), de 2 à 6 semaines. Il n’est pas permis d’ajouter du temps à la durée d’une itération si le projet avance plus lentement que prévu, car cela impliquerait un retard de la rétroaction du client. Si le respect des délais semble compromis, on supprime plutôt des tâches ou des spécifications et on les reprend éventuellement dans une itération ultérieure.\nLes premières itérations peuvent sembler chaotiques, car elles peuvent être loin de la « bonne voie » ou du résultat convoité. Avec la rétroaction du client et l’adaptation, le système à développer converge vers une solution appropriée (figure 2.2 ). Cette instabilité peut être particulièrement prononcée dans un contexte d’entreprise en démarrage.\nDans une itération, la modélisation (par exemple avec l’UML) se fait au début et devrait prendre beaucoup moins de temps (quelques heures) que la programmation, qui n’est pas triviale (voir la figure 1.8). Selon le contexte du projet (voir le Spectre de la conception), on peut décider de ne pas faire de modélisation. Cependant, en fonction de la complexité du projet à réaliser, cela peut amener des risques, ce que l’on appelle la dette technique.\n\n\n\nFaire planification initialPlanifier nouvelle itérationPlan d'itération (nouveaux objectifs)Élaborer (nouvelles) exigencesActualiser analyse, conception, code et testsNouvelle implémentationNouveau déploiementFaire démonstration et cueillir rétroactionprojet en coursouinon\nFigure 1.6: Un processus itératif permet de gérer les complexités, car la planification d’une itération peut viser une partie du système et le système évolue à mesure que les itérations avancent.\n\n\n\n\n\nFigure 1.7: Processus itératif et incrémental (évolutif).\n\n\nLe développement itératif et incrémental amène plusieurs avantages selon Larman (2005) :\n\n\n\n\n\n\n\nune diminution d’échecs, une amélioration de la productivité et de la qualité ;\nune gestion proactive des risques élevés (risques techniques, exigences, objectifs, convivialité, etc.) ;\ndes progrès immédiatement visibles ;\nla rétroaction, l’implication des utilisateurs et l’adaptation précoces ;\nla gestion de la complexité (restreinte à une itération) ;\nla possibilité d’exploiter méthodiquement les leçons tirées d’une itération.\n\n\n\n\nCependant, il y a des défis associés à ce genre de développement :\n\nInstabilité apparente au début. Dans les itérations initiales, puisqu’on n’a pas beaucoup de temps pour comprendre les exigences, le domaine du client et les contraintes du projet, la compréhension des spécifications et la conception sont loin de la « bonne voie ». La conséquence est que les évaluations et les rétroactions peuvent sembler rudes, et cela peut être déstabilisant pour des personnes qui ne sont pas familières avec le processus. La bonne nouvelle est que, normalement, cette instabilité diminue au fur et à mesure que le projet avance (voir la figure 2.2 ).\nModifications des objectifs de l’itération en cours au besoin. Il arrive souvent que, dans une itération, les choses ne se passent pas comme nous l’avons imaginé. Par exemple, l’ensemble des récits utilisateur ou des scénarios de cas d’utilisation visés pour l’itération nécessite plus de travail que prévu. La tendance dans ce cas est de nous donner plus de temps pour terminer ces étapes. Mais cela voudrait dire que la rétroaction de toute l’itération sera retardée. Il serait nécessaire de changer la planification de la démonstration avec le client (qui a souvent peu de disponibilités). Donc, le processus nous impose de toujours respecter le délai des itérations. Il s’agit d’une gestion par blocs de temps (en anglais timeboxing). Que faire alors si, dans une itération, nous n’arriverons pas à tout faire ? La résolution est de demander à l’équipe après la moitié de l’itération si les objectifs d’origine peuvent être atteints. Si la réponse est non, nous priorisons les objectifs en plaçant les objectifs secondaires dans la catégorie des « choses à faire » (qui seront éventuellement faites à une itération ultérieure). Voir la figure 1.8. Selon une étude menée par Blincoe et coll. (2019) sur trois gros projets itératifs d’IBM, jusqu’à 54 % des exigences de haut niveau ont été déplacées de cette manière. Le but ultime de cette stratégie est de pouvoir faire une démonstration à la fin de l’itération, même si elle ne comprend pas toutes les fonctionnalités visées au début, car la rétroaction régulière sur des choses qui fonctionnent est essentielle.\n\n\n\n\nFigure 1.8: Pour respecter la méthode du temps limité, on peut modifier les objectifs d’une itération si le travail est trop important (selon Larman, 2005, fig. 2.4).\n\n\n\n\n\n\nBlincoe, K., Dehghan, A., Salaou, A.-D., Neal, A., Linaker, J., et Damian, D. (2019). High-level software requirements and iteration changes: a predictive model. Empirical Software Engineering, 24(3), 1610‑1648.\n\n\nGamma, E., Helm, R., Johnson, R., et Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software (1ʳᵉ éd.). Reading, Mass : Addison-Wesley Professional. Repéré à http://amazon.com/o/ASIN/0201633612/\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "Besoins.html#furps",
    "href": "Besoins.html#furps",
    "title": "2  Besoins (exigences)",
    "section": "2.1 FURPS+",
    "text": "2.1 FURPS+\nFURPS+ est un modèle (avec un acronyme) pour classer les exigences (besoins) d’un logiciel. Voici un résumé de FURPS+ (voir Larman, 2005, sect. 5.4 ) :\n\nFonctionnalité (Functionality). Ce sont les exigences exprimées souvent par les cas d’utilisation, par exemple Traiter une vente. La sécurité est aussi considérée dans ce volet.\nAptitude à l’utilisation (Usability). Convivialité : les facteurs humains du logiciel, par exemple le nombre de clics que ça prend pour réaliser une fonctionnalité, à quel point une interface est facile à comprendre par une personne, etc.\nFiabilité (Reliability). Comment le logiciel doit se comporter lorsqu’il y a des problèmes ou des pannes. Par exemple, un logiciel de traitement de texte produit un fichier de sauvegarde de secours, ou une application continue à fonctionner même hors connexion (si le réseau Internet est coupé ou désactivé).\nPerformance (Performance). Comment un logiciel doit se comporter lors d’une charge importante sur le système. Par exemple, lors de la période d’inscription universitaire, le système doit avoir un temps de réponse de moins de 2 secondes.\nPossibilités de prise en charge (Supportability). Adaptabilité ou maintenabilité : à quel point le logiciel sera facile à modifier face aux changements prévus. Par exemple, lors d’un changement de lois fiscales, quelles caractéristiques de la conception vont faciliter le développement d’une nouvelle version du logiciel.\n« + » : Comprend toutes les autres choses :\n\nImplémentation. Par exemple, le projet doit être réalisé avec des bibliothèques et des langages qui ne sont pas payants (logiciel libre).\nInterface. Par exemple, les contraintes d’interfaçage avec un système externe.\nExploitation. Par exemple, l’utilisation d’un système d’intégration continue.\nAspects juridiques. Par exemple, la licence du logiciel, les politiques de confidentialité et d’utilisation des données personnelles, etc.\n\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "CasUtilisation.html#exemple-jeu-de-risk",
    "href": "CasUtilisation.html#exemple-jeu-de-risk",
    "title": "3  Cas d’utilisation",
    "section": "3.1 Exemple : le jeu Risk",
    "text": "3.1 Exemple : le jeu Risk\nNous décrivons un cas d’utilisation à l’aide d’un exemple concernant le jeu Risk.\n\n\n\nCinq dés utilisés dans le jeu Risk. « Risk Dice » (CC BY 2.0). Par Fuhrmanator.\n\n\nSelon « Risk ». 2019. Wikipédia. (accédé le 9 décembre 2019) :\n\n\n\n\n\n\nL’attaquant jette un à trois dés suivant le nombre de régiments qu’il désire engager (avec un maximum de trois régiments engagés, et en considérant qu’un régiment au moins doit rester libre d’engagements sur le territoire attaquant) et le défenseur deux dés (un s’il n’a plus qu’un régiment). On compare le dé le plus fort de l’attaquant au dé le plus fort du défenseur et le deuxième dé le plus fort de l’attaquant au deuxième dé du défenseur. Chaque fois que le dé du défenseur est supérieur ou égal à celui de l’attaquant, l’attaquant perd un régiment ; dans le cas contraire, c’est le défenseur qui en perd un.\n\n\n\nAlors, nous proposons les étapes (les interactions entre les acteurs et le système) pour ce scénario :\n\n3.1.1 Scénario : Attaquer un pays\n\nLe Joueur attaquant choisit d’attaquer un pays voisin du Joueur défenseur.\nLe Joueur attaquant annonce combien de régiments il va utiliser pour son attaque.\nLe Joueur défenseur annonce combien de régiments il va utiliser pour la défense du pays attaqué.\nLes deux Joueurs jettent le nombre de dés selon leur stratégie, choisie aux étapes précédentes.\nLe Système compare les dés, élimine les régiments de l’attaquant ou du défenseur selon les règles1 et affiche le résultat.\n\nLes Joueurs répètent les étapes 2 à 5 jusqu’à ce que l’attaquant ait éliminé tous les régiments du pays attaqué, l’attaquant n’ait plus suffisamment de régiments pour attaquer, ou l’attaquant ne veuille plus attaquer.\n\nLe Système indique le résultat de l’attaque, y compris un changement de contrôle du pays attaqué si nécessaire.\n\n\n\n3.1.2 Scénarios alternatifs (ou extensions)\nLes compléments du scénario principal (ce qui se passe le plus souvent) sont les scénarios alternatifs, qui comprennent souvent la plus grande partie du texte de cas d’utilisation. Ils indiquent tous les autres cas ou branchements éventuels, ce qui peut représenter beaucoup de fonctionnalités d’un logiciel complet. Par exemple, un client ou une cliente veut payer avec Bitcoin (le logiciel doit supporter ce cas moins fréquent). Un autre exemple est lorsque la validation de carte de crédit échoue lors d’un paiement.\nLes scénarios alternatifs sont documentés dans une section du cas d’utilisation à ce propos. On spécifie les étapes du scénario de base auxquelles il peut y avoir un branchement. Dans l’exemple du jeu Risk, lors d’une attaque, le Joueur attaquant peut décider spontanément d’annuler son attaque. Il ne pourra pas l’annuler une fois que les dés sont lancés. Alors on peut spécifier le scénario alternatif « 2-3a », pour indiquer que ça commence à partir des étapes 2 et 3 du scénario principal et que c’est le premier (« a ») scénario alternatif pour ces étapes :\n\n\n\n\n\n\nScénarios alternatifs :\n\n\n\n2-3a. Le Joueur attaquant décide d’annuler son attaque.\n\nLe Système indique que le Joueur attaquant a annulé.\nFin du cas d’utilisation\n\n\n\n\n\n3.1.3 Diagramme de cas d’utilisation\nLa figure 3.1 est un exemple de diagramme de cas d’utilisation.\nUn diagramme de cas d’utilisation n’étant qu’une sorte de table des matières des fonctionnalités, il ne montre qu’une faible partie des détails trouvés dans le texte de chaque cas d’utilisation. Le diagramme ne peut donc remplacer la documentation textuelle.\nSur la figure 3.1, le cas d’utilisation « … » signifie qu’il y a d’autres cas d’utilisation à spécifier concrètement, c’est-à-dire tous les autres cas d’utilisation du jeu, par exemple pour distribuer les régiments à chaque tour, etc.\nLe cas d’utilisation Démarrer n’est pas normalement indiqué dans un diagramme. C’est une astuce pédagogique proposée par Larman (2005), car il faudra concevoir et coder ce scénario, bien qu’il ne soit pas une fonctionnalité connue par l’utilisateur.\n\n\nSystème...Attaquerun paysDémarrerJoueur\nFigure 3.1: Diagramme de cas d’utilisation.\n\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "MDD.html#classes-conceptuelles",
    "href": "MDD.html#classes-conceptuelles",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.1 Classes conceptuelles",
    "text": "4.1 Classes conceptuelles\nIl y a trois stratégies pour identifier les classes conceptuelles :\n\nRéutiliser ou modifier des modèles existants.\nUtiliser une liste de catégories.\nIdentifier des groupes nominaux.\n\n\n4.1.1 Catégories pour identifier des classes conceptuelles\n\nExtrait du tableau 9.1 \n\n\n\n\n\n\nCatégorie\nExemples\n\n\n\n\nTransactions d’affaires : Elles sont essentielles, commencez l’analyse par les transactions.\nVente, Attaque, Réservation, Inscription, EmpruntVélo\n\n\nLignes d’une transaction : Éléments compris dans une transaction.\nLigneArticles, ExemplaireLivre, GroupeCours\n\n\nProduit ou service lié à une transaction ou à une ligne de transaction : Pour quel concept sont faites des transactions ?\nArticle, Vélo, Vol, Livre, Cours\n\n\nOù la transaction est-elle enregistrée ?\nCaisse, GrandLivre, ManifesteDeVol\n\n\nRôle des personnes liées à la transaction : Qui sont les parties impliquées dans une transaction ?\nCaissier, Client, JoueurDeMonopoly, Passager\n\n\nOrganisations liées à la transaction : Quelles sont les organisations impliquées dans une transaction ?\nMagasin, CompagnieAérienne, Bibliothèque, Université\n\n\nLieu de la transaction, lieu du service\nMagasin, Aéroport, Avion, Siège, LocalCours\n\n\nÉvénements notables, à mémoriser\nVente, Paiement, JeuMonopoly, Vol\n\n\nObjets physiques : Importants surtout lorsqu’il s’agit d’un logiciel de contrôle d’équipements ou de simulation.\nArticle, Caisse, Plateau, Pion, Dé, Vélo\n\n\nDescription d’entités : Voir section 9.13  pour plus d’informations.\nDescriptionProduit, DescriptionVol, Livre (en opposition avec Exemplaire), Cours (en opposition avec CoursGroupe)\n\n\nCatalogues : Les descriptions se trouvent souvent dans des catalogues.\nCatalogueProduits, CatalogueVols, CatalogueLivres, CatalogueCours\n\n\nConteneurs : Un conteneur peut contenir des objets physiques ou des informations.\nMagasin, Rayonnage, Plateau, Avion, Bibliothèque\n\n\nContenu d’un conteneur\nArticle, Case (sur un Plateau de jeu), Passager, Exemplaire\n\n\nAutres systèmes externes\nSystèmeAutorisationPaiementsÀCrédit, SystèmeGestionBordereaux\n\n\nDocuments financiers, contrats, documents légaux\nReçus, GrandLivre, JournalDeMaintenance\n\n\nInstruments financiers\nEspèces, Chèque, LigneDeCrédit\n\n\nPlannings, manuels, documents régulièrement consultés pour effectuer un travail\nMiseÀJourTarifs, PlanningRéparations"
  },
  {
    "objectID": "MDD.html#attributs",
    "href": "MDD.html#attributs",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.2 Attributs",
    "text": "4.2 Attributs\nLes attributs sont le sujet de la section 9.16 . Comme c’est le cas pour les classes et les associations, on fait figurer les attributs quand les cas d’utilisation suggèrent la nécessité de mémoriser des informations.\nPour l’UML, la syntaxe complète d’un attribut est :\nvisibilité nom : type multiplicité = défaut {propriété}\nVoici des points importants :\n\nLe type d’un attribut est important, et il faut le spécifier dans un MDD, même si dans le livre de Larman (2005), il y a plusieurs exemples sans type.\nNe vous souciez pas de la visibilité des attributs dans un MDD.\nFaites attention à la confusion des attributs et des classes. Si l’on ne pense pas un concept X en termes alphanumériques dans le monde réel, alors il s’agit probablement d’une classe conceptuelle. Par exemple, dans le monde réel, une université n’est composée ni de chiffres ni de lettres. Elle doit être une classe conceptuelle. Voir la section 9.12 .\nDe la même manière, faites attention aux informations qui sont mieux modélisées par des associations. Par exemple, sur la figure 4.2, la classe Pays n’a pas un attribut joueur:Joueur (qui contrôle le Pays) ; elle a plutôt une association avec la classe Joueur et un verbe contrôle.\n\n\n\n\n\n\n\nIl est vrai que dans un langage de programmation comme Java, les associations doivent être les attributs dans les classes, car il s’agit des classes logicielles. Cependant, dans un modèle du domaine, on évite des attributs si une association peut mieux décrire la relation. La relation relie visuellement les deux classes conceptuelles et elle est décrite avec un verbe."
  },
  {
    "objectID": "MDD.html#associations",
    "href": "MDD.html#associations",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.3 Associations",
    "text": "4.3 Associations\nLes associations dans le MDD sont le sujet de la section 9.14 . Il faut se référer au contenu du livre de Larman pour les détails. Une association est une relation entre des classes (ou des instances de classes). Elle indique une connexion significative ou intéressante. Voici des points importants :\n\nIl est facile de trouver beaucoup d’associations, mais il faut se limiter à celles qui doivent être conservées un certain temps. Pensez à la mémorabilité d’une association dans le contexte du logiciel à développer. Par exemple, considérez les associations de la figure 4.2 :\n\nIl existe une association entre Joueur et Pays, car il est important de savoir quel joueur contrôle quel pays dans le jeu Risk.\nIl n’y a pas d’association entre JeuRisk et Attaque, même si les attaques font partie du jeu. Il n’est pas essentiel de mémoriser l’historique de toutes les attaques réalisées dans le jeu.\n\nIl y a des associations dérivées de la liste des associations courantes. Voir le tableau 4.1.\nEn UML, les associations sont représentées par des lignes entre les classes.\n\nElles sont nommées (avec un verbe commençant par une lettre majuscule).\nDes verbes simples comme « A », « Utilise », « Possède », « Contient », etc. sont généralement des choix médiocres, car ils n’aident pas notre compréhension du domaine. Essayez de trouver des verbes plus riches, si possible.\nUne flèche (triangle) de « sens de lecture » optionnelle indique la direction dans laquelle lire l’association. Si la flèche est absente, on lit l’association de gauche à droite ou de haut en bas.\nLes extrémités des associations ont une expression de la multiplicité indiquant une relation numérique entre les instances des classes. Vous pouvez en trouver plusieurs exemples sur la figure 4.2.\n\nLes associations ne doivent pas être représentées avec des attributs. Les associations servent à représenter les relations purement conceptuelles afin de documenter le domaine. Elles ne visent pas à documenter la structure des données ou les instances de variables qu’on retrouve dans le logiciel. Contrairement aux associations des diagrammes de classes logicielles, ce ne sont pas toutes les associations conceptuelles qui seront implémentées dans le logiciel.\n\n\n\nTableau 4.1: Extrait du tableau 9.2  (liste d’associations courantes)\n\n\n\n\n\n\nCatégorie\nExemples\n\n\n\n\nA est une transaction liée à une transaction B\nPaiementEnEspèces – Vente\nRéservation – Annulation\n\n\nA est un élément d’une transaction B\nLigneArticles – Vente\n\n\nA est un produit pour une transaction (ou un élément de transaction) B\nArticle – LigneArticles (ou Vente)\nVol – Réservation\n\n\nA est un rôle lié à une transaction B\nClient – Paiement\nPassager – Billet\n\n\nA est une partie logique ou physique de B\nTiroir – Registre\nCase – Plateau\nSiège – Avion\n\n\nA est physiquement ou logiquement contenu dans B\nRegistre – Magasin\nJoueur – Monopoly\nPassager – Avion\n\n\nA est une description de B\nDescriptionProduit – Article\nDescriptionVol – Vol\n\n\nA est connu/consigné/enregistré/saisi dans B\nVente – Registre\nPion – Case\nRéservation – ManifesteDeVol\n\n\nA est un membre de B\nCaissier – Magasin\nJoueur – Monopoly\nPilote – CompagnieAérienne\n\n\nA est une sous-unité organisationnelle de B\nRayon – Magasin\nMaintenance – CompagnieAérienne\n\n\nA utilise, gère ou possède B\nCaissier – Registre\nJoueur – Pion\nPilote – Avion\n\n\nA est voisin de B\nArticle – Article\nCase – Case\nVille – Ville"
  },
  {
    "objectID": "MDD.html#attributs-dérivés",
    "href": "MDD.html#attributs-dérivés",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.4 Attributs dérivés",
    "text": "4.4 Attributs dérivés\nLes attributs dérivés sont expliqués en détail dans la section 9.16 . Il s’agit des attributs qui sont calculés à partir d’autres informations reliées à la classe. Ils sont indiqués par le symbole / devant leur nom.\nL’exemple à la figure 4.1 s’applique à la règle du jeu Risk spécifiant qu’un joueur reçoit un certain nombre de renforts selon le nombre de pays occupés. La classe Joueur pourrait avoir un attribut dérivé /nbPaysOccupés qui est calculé selon le nombre de Pays contrôlés par le joueur.\n\n\nJoueurnom : String/nbPaysOccupés : intPaysnom : StringContrôle11..*\nFigure 4.1: nbPaysOccupés est un attribut dérivé. Sa valeur sera calculée selon le nombre de pays de l’association."
  },
  {
    "objectID": "MDD.html#exemple-de-mdd-pour-le-jeu-risk",
    "href": "MDD.html#exemple-de-mdd-pour-le-jeu-risk",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.5 Exemple de MDD pour le jeu Risk",
    "text": "4.5 Exemple de MDD pour le jeu Risk\nLa figure 4.2 est un MDD pour le jeu Risk, selon l’exemple mentionné dans le chapitre sur les cas d’utilisation. Commençons par la classe JeuRisk, qui est l’objet racine du modèle. Il est relié à la classe Joueur, puisqu’un joueur « joue » à JeuRisk (notez le triangle pour le sens de lecture). Selon les cardinalités de l’association entre ces deux classes, il peut y avoir entre deux (2) et six (6) personnes qui jouent au jeu. Le jeu « inclut » cinq objets de la classe Dé, mais un Joueur jette un, deux ou trois dés (selon la règle du jeu Risk). L’association entre Joueur et Pays a un verbe « contrôle », qui est un exemple de verbe plus riche que « possède » ou « a ». L’association entre Continent et Pays représente la composition des territoires (un synonyme pour pays) des différents continents, soit 4 (pour l’Amérique du sud et l’Océanie), 6 (pour l’Afrique), 7 (pour l’Europe), 9 (pour l’Amérique du nord) et 12 (pour l’Asie). Si vous regardez tout le modèle, vous verrez qu’il représente visuellement beaucoup d’éléments du jeu.\n\n\nJoueurnom : String/nbPaysOccupés : intDévaleur : intJeuRiskPlateauRiskPaysnom : StringAttaquenbAttaquant : intnbDéfenseur : intOccupationnbRégiments : intContinentContient142Est-divisé-en16Groupe14, 6,7, 9,12Est-voisin-de11..*Est-joué-sur11Inclut15Joue12:6Contrôle11..*Lance1..*1Défend-contre11..* Jette11,2,3\nFigure 4.2: Modèle du domaine du jeu Risk."
  },
  {
    "objectID": "MDD.html#classes-de-description-et-classes-de-catalogue",
    "href": "MDD.html#classes-de-description-et-classes-de-catalogue",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.6 Classes de « description » et classes de catalogue",
    "text": "4.6 Classes de « description » et classes de catalogue\nDeux catégories de classes conceptuelles qui vont de pair sont les descriptions d’entités et les catalogues qui agrègent les descriptions. Elles sont expliquées en détail dans la section 9.13 . Voici des conditions pour utiliser correctement une classe de description d’une autre classe « X » :\n\nIl faut disposer de la description d’un produit ou d’un service « X » indépendamment de l’existence actuelle des « X ». Par exemple, il pourrait y avoir une rupture de stock d’un Produit (aucune instance actuelle), mais on a besoin de connaître son prix. La classe DescriptionProduit permet d’avoir cette information, même s’il n’y a plus d’instances de Produit. Un autre exemple est un trimestre où un cours LOG711 ne se donne pas (il n’y a pas de GroupeCours de LOG711 dans le trimestre actuel). Alors, une classe Cours (qui joue le rôle de description) sert pour spécifier le nombre de crédits, les cours préalables, etc.\nLa suppression d’instances de la classe « X » entraîne la perte de l’information qui doit être mémorisée, mais qui a été incorrectement associée à l’entité en question.\nLa classe de description réduit la duplication des informations.\n\nLa figure 4.3 présente une classe de description pour le contexte de cours et de groupe-cours.\n\n\nGroupeCoursnuméro : inttrimestre : Trimestre...Coursnom : TextenbCrédits : int...CatalogueCoursClasse de « description ». Une instance de Cours peut existerindépendamment de l'existence d'un GroupeCours qu'elle décrit(par exemple, avant qu'un cours soit donné la première fois).Elle réduit également la duplication des informations (le nom etle nombre de crédits ne sont pas stockés dans chaque GroupeCours).Décrit1*Est-préalable-à1*Répertorie1*\nFigure 4.3: La classe Cours joue le rôle de description d’entités (les groupes-cours).\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention de ne pas faire l’erreur naïve d’utiliser une classe de description simplement pour « décrire » une autre classe. Voir la figure 4.4 pour un exemple.\n\n\n\n\nClientDescriptionClientnom : Texteidentifiant : IDClient...CatalogueClientsMauvaise classe de « description ». Il n'est pas nécessaired'avoir cette classe, car les clients sont décrits dans leurpropre classe Client. Si un client n'existe pas, il n'a pas desens dans le MDD. Les informations ne seraient pas dupliquéess'il n'y avait pas cette classe (chaque client a un nom et unidentifiant unique).Décrit11Répertorie1*\nFigure 4.4: Illustration d’une erreur fréquente : utiliser une classe de description sans justification."
  },
  {
    "objectID": "MDD.html#classes-dassociation",
    "href": "MDD.html#classes-dassociation",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.7 Classes d’association",
    "text": "4.7 Classes d’association\nLes classes d’association dans un MDD sont le sujet de la section F26.10/A31.10 .\n\n\n\n\n\n\nUne classe d’association permet de traiter une association comme une classe et de la modéliser avec des attributs.\n\n\n\nIl pourrait être utile d’avoir une classe d’association dans un MDD :\n\nsi un attribut est lié à une association ;\nsi la durée de vie des instances de la classe d’association dépend de l’association ;\ns’il y a une association N-N entre deux concepts et des informations liées à l’association elle-même.\n\nL’exemple illustré sur la figure 4.5 explique la nécessité d’une classe d’association Occupation. Lorsqu’un Joueur contrôle un Pays, il doit déployer des armées dans ce dernier. Le MDD pourrait avoir un attribut nbRégiments dans la classe Pays. Cependant, l’attribut nbRégiments est lié à l’association entre le Joueur et le Pays qu’il contrôle, alors on décide d’utiliser une classe d’association.\nSi un Joueur envahit un Pays, la nouvelle instance de la classe d’association Occupation sera créée (avec la nouvelle association). Pourtant, cette instance d’Occupation sera détruite si un autre Joueur arrive à prendre le contrôle du Pays. Alors, la durée de vie de cette instance dépend de l’association.\nVoir le livre de Larman (2005) pour plus d’exemples.\n\n\nJoueurnom : String/nbPaysOccupés : intPaysnom : StringOccupationnbRégiments : intContrôle11..*\nFigure 4.5: Classe d’association dans le MDD Jeu Risk."
  },
  {
    "objectID": "MDD.html#affinement-du-mdd",
    "href": "MDD.html#affinement-du-mdd",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.8 Affinement du MDD",
    "text": "4.8 Affinement du MDD\nLorsqu’on modélise un domaine, il est normal de commencer par un modèle simple (à partir d’un ou de deux cas d’utilisation) et ensuite de l’affiner dans les itérations suivantes, où l’on y intègre d’autres éléments plus subtils ou complexes du problème qu’on étudie. Les détails de cette approche sont présentés dans le chapitre F26/A31 . Bien que la matière soit présentée plus tard dans le livre, ce sont des choses à savoir pour la modélisation d’un domaine, même dans une première itération.\nVoici un résumé des points importants traités dans ce chapitre, dont quelques-uns ont déjà été présentés plus haut :\n\nComposition, par exemple la classe Continent qui groupe les Pays sur la figure 4.2. Larman propose d’utiliser la composition lorsque :\n\nla durée de vie du composant est limitée à celle du composite (lorsqu’un objet Continent est instancié, ça doit grouper des instances de Pays pour être cohérent), il existe une dépendance création-suppression de la partie avec le tout (ça ne fait pas de sens de supprimer un objet Pays d’une instance de Continent dans le jeu Risk) ;\nil existe un assemblage logique ou physique évident entre le tout et les parties (on ne peut construire un Continent sans les Pays) ;\ncertaines propriétés du composite, comme son emplacement, s’étendent aux composants ;\nles opérations que l’on peut appliquer au composite, telles que destruction, déplacement et enregistrement, se propagent aux composants.\n\nGénéralisation/spécialisation (voir Larman, 2005 pour les exemples et les directives), notamment la règle des 100 % (conformité à la définition) et la règle « est-un » (appartenance à l’ensemble).\nAttribut dérivé, par exemple, /nbPaysOccupés dans la classe Joueur est un attribut dérivé de l’association entre Joueur et Pays (figure 4.1).\nHiérarchies dans un MDD et héritage dans l’implémentation.\nNoms de rôles.\nOrganisation des classes conceptuelles en packages (surtout lorsque le MDD contient un nombre important de classes conceptuelles)."
  },
  {
    "objectID": "MDD.html#faq-mdd",
    "href": "MDD.html#faq-mdd",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.9 FAQ MDD",
    "text": "4.9 FAQ MDD\n\n4.9.1 Y a-t-il un MDD pour chaque cas d’utilisation ?\nSelon la méthodologie de ce manuel, bien qu’une application ait souvent plusieurs fonctionnalités (cas d’utilisation), il n’y a qu’un seul MDD.\nCela dit, le MDD est comme un fichier de code source, puisque sa version peut évoluer avec le projet. Le MDD évoluera normalement après chaque itération, car on fait une nouvelle analyse pour les nouvelles fonctionnalités visées dans l’itération. Au début du projet, le MDD est plus simple, puisqu’il porte sur seulement les cas d’utilisation ciblés à la première itération. Le MDD devient plus riche au fur et à mesure qu’on avance dans les itérations, parce qu’il modélise davantage de concepts reliés aux problèmes traités par les nouvelles fonctionnalités à réaliser.\nPar exemple, la version initiale du MDD (chapitre 9 ) ne traite pas la fonctionnalité de paiement par carte de crédit. Les classes conceptuelles modélisant la problématique de paiement par carte de crédit sont absentes dans le MDD initial. Plus tard (après plusieurs itérations, dans le chapitre sur le raffinement du MDD), on voit un MDD beaucoup plus riche qui reflète la modélisation des concepts reliés à des fonctionnalités comme les paiements par carte de crédit, les demandes d’autorisation de paiement, etc.\n\n\n4.9.2 Un modèle du domaine est-il la même chose qu’un modèle de données ?\nVoici la réponse de Craig Larman (2005) dans la section 9.2  :\n\n\n\n\n\n\nUn modèle du domaine n’est pas un modèle de données ([ce dernier] représente par définition des objets persistants stockés quelque part).\n\n\n\nIl peut y avoir des concepts dans un domaine qui ne sont pas dans la base de données. Considérez l’exemple de la carte de crédit utilisée pour payer, mais qui n’est jamais stockée pour des raisons de sécurité. Avec seulement un modèle de données, cette classe conceptuelle ne serait jamais modélisée. Larman précise :\n\n\n\n\n\n\nN’excluez donc pas une classe simplement parce que les spécifications n’indiquent pas un besoin évident de mémoriser les informations la concernant (un critère courant pour la modélisation des données quand on conçoit des bases de données relationnelles, mais qui n’a pas cours en modélisation d’un domaine), ou parce que la classe conceptuelle ne possède pas d’attributs. Il est légal d’avoir une classe conceptuelle sans attribut, ou une classe conceptuelle qui joue un rôle exclusivement comportemental dans le domaine.\n\n\n\nVous pouvez aussi lire cette question ."
  },
  {
    "objectID": "MDD.html#exercices",
    "href": "MDD.html#exercices",
    "title": "4  Modèle du domaine (MDD, modèle conceptuel)",
    "section": "4.10 Exercices",
    "text": "4.10 Exercices\n\nExercice 4.1 (Trouver des classes conceptuelles par catégorie) À partir du cas d’utilisation Réserver un livre de la bibliothèque, trouvez des classes conceptuelles candidates en utilisant une liste de catégories de classes. Vous pouvez remplir un tableau comme ceci :\n\n\n\n\n\n\n\nCatégorie de classes conceptuelles\nClasses candidates selon le cas d’utilisation\n\n\n\n\nTransaction d’affaires (métier)\nRéservation (Ceci est un exemple.)\n\n\n(Continuez avec d’autres catégories.)\n\n\n\n(Certaines catégories ne s’appliqueront pas.)\n\n\n\n\n(Certaines classes candidates seront découvertes par plusieurs catégories.)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice 4.2 (Classes conceptuelles trouvées à l’aide de groupes nominaux) Cette fois-ci, utilisez les groupes nominaux pour trouver des classes conceptuelles candidates. Commencez par souligner ou par mettre en surbrillance les noms et les groupes nominaux dans le cas d’utilisation Réserver un livre de la bibliothèque. Les groupes nominaux peuvent être des classes ou des attributs, ou peuvent ne pas s’appliquer du tout. Faites une liste de classes conceptuelles candidates (sans doublons).\n\n\n\nExercice 4.3 (Comparaison des approches) Comparez la liste des classes trouvées dans l’Exercice 4.2 avec les classes trouvées dans l’Exercice 4.1. Quelles sont les différences ?\n\n\n\n\n\n\n\nNote\n\n\n\nVous pouvez dessiner les diagrammes à la main et en prendre une photo avec une application comme Microsoft Lens (Android, iOS).\nVous pouvez également utiliser PlantUML. Voici des ressources à ce propos : \n\ntutoriel VS Code sur YouTube \nextension PlantUML pour VS Code ;\nPlantUML Gizmo, module supplémentaire Google Docs ;\nPlantText.com.\n\nMéfiez-vous des outils comme Lucidchart ayant seulement des profils superficiels (sans règles) pour l’UML. Voir la figure 13.5 pour plus de détails.\n\n\n\nExercice 4.4 (Diagramme de classes conceptuelles) À partir du cas d’utilisation Réserver un livre de la bibliothèque, esquissez le modèle du domaine correspondant au domaine de l’application (cela comprend des classes, des attributs et des associations).\n\nConsidérez les classes candidates provenant de l’Exercice 4.1 et de l’Exercice 4.2.\nNotez que les classes candidates dénichées ne sont pas toujours importantes. Certains concepts sont des attributs. D’autres (surtout avec l’approche linguistique) n’ont rien à voir avec le problème du domaine. Vous devez appliquer les directives vues dans le chapitre 9 .\nFaites attention à bien modéliser la classe de « description » dans ce problème.\nTout attribut doit avoir un type.\nLimitez-vous à des associations « mémorisables » dans le contexte de l’application du logiciel (ne pas faire des associations hors de la portée du cas d’utilisation).\nVérifiez les cardinalités.\nVérifiez les verbes sur les associations ainsi que le sens de lecture.\n\n\n\nExercice 4.5 (Création du MDD du logiciel Discord par rétro-ingénierie) Par rétro-ingénierie, réalisez le modèle du domaine pour une fonctionnalité du logiciel Discord.\n\nConnectez-vous au logiciel Discord. Si vous n’avez pas de compte Discord, vous pouvez en créer un temporairement. Sur le site web de Discord, cliquez sur « Ouvrir Discord dans ton navigateur ».\nDans l’application Discord, créez un nouveau serveur et envoyez un message qui contient un fichier et du texte dans un salon textuel.\nÀ l’aide de la liste de catégories de classes conceptuelles, proposez les classes conceptuelles qui sont nécessaires pour réaliser la fonctionnalité de l’étape précédente.\n\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\n\n\n\nCatégorie\nClasses conceptuelles\n\n\n\n\nTransactions d’affaires\nMessage\n\n\nRôle des personnes liées à la transaction\nUtilisateur\n\n\nLieu de la transaction, lieu du service\nSalon textuel, Salon\n\n\nConteneurs\nServeur, Profil, Fichier\n\n\n\n\n\n\n\nProposez les attributs de chaque classe conceptuelle qui sont nécessaires pour réaliser la fonctionnalité.\n\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nVoici une solution possible qui est cohérente avec l’étape précédente :\n\n\nMessagecontenu : Stringhorodatage : DateHeureUtilisateurcourriel : StringnomUtilisateur : StringnomAffichage : StringSalonnom : StringSalonTextuelsujet : StringServeurnom : StringProfilavatar : FileFichierurl : String\nFigure 4.6: Attributs des classes conceptuelles proposées dans l’exercice.\n\n\n\n\n\n\nProposez les associations entre les classes conceptuelles ainsi que leurs cardinalités.\n\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nVoici une solution possible qui est cohérente avec l’étape précédente :\n\n\nUtilisateurcourriel : StringnomUtilisateur : StringnomAffichage : StringMessagecontenu : Stringhorodatage : DateHeureSalonTextuelsujet : StringProfilavatar : FileServeurnom : StringFichierurl : StringSalonnom : StringRédige1*Publie1*Représente11Est-membre-de1..**Est-propriétaire-de1*Héberge1*Est-joint-à1*Est-membre-de1..**\nFigure 4.7: Associations et cardinalités des classes conceptuelles proposées dans l’exercice.\n\n\n\n\n\n\n\nExercice 4.6 (Utiliser des verbes plus riches pour décrire les associations) La figure 4.8 présente une modèle du domaine partiel pour le logiciel YouTube. Toutefois, les associations du MDD utilisent des verbes ternes qui n’aident pas à comprendre le domaine. Remplacez les verbes des associations par des verbes plus riches. Vous pouvez inverser le sens des associations.\n\n\nUtilisateurnomUtilisateur : Stringcourriel : StringChaînedescription : StringVidéotitre : Stringdescription : Stringurl : StringListeDeLecturenom : Stringdescription : Stringvisibilite : StringSousTitrelangue : StringStatistiquevisionnements : intdureeVisionnement : floatimpressions : intPossède1*Contient1*Possède1*Contient**A1*Possède11\nFigure 4.8: Modèle du domaine partiel pour le logiciel YouTube.\n\n\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\n\n\nUtilisateurnomUtilisateur : Stringcourriel : StringChaînedescription : StringVidéotitre : Stringdescription : Stringurl : StringListeDeLecturenom : Stringdescription : Stringvisibilite : StringSousTitrelangue : StringStatistiquevisionnements : intdureeVisionnement : floatimpressions : intGère1*Publie1*Administre1*Enregistre**Est-plus-accessible-avec1*Mesure-visualisation-de11\nFigure 4.9: Modèle du domaine partiel pour le logiciel YouTube avec des verbes d’association plus riches.\n\n\n\n\n\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "DSS.html#linterface-de-programmation-application-programming-interface",
    "href": "DSS.html#linterface-de-programmation-application-programming-interface",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.1 L’interface de programmation (Application Programming Interface)",
    "text": "5.1 L’interface de programmation (Application Programming Interface)\nSelon l’Office québécois de la langue française, l’interface de programmation est l’ensemble de routines standards, accessibles et documentées, qui sont destinées à faciliter au programmeur [et à la programmeuse] le développement d’applications. Le terme en anglais est Application Programming Interface (API). En d’autres mots, c’est la façon (normalisée et documentée) dont un programme d’application communique avec un ensemble d’éléments logiciels qu’il utilise pour faire une application utile.\nPar exemple, une classe dans un logiciel orienté objet peut être utilisée pour créer une application. Les méthodes publiques de la classe composent son interface API, comme le montre la figure 5.1. Un logiciel en ligne de commande peut aussi servir pour des applications. Les commandes et les paramètres que le logiciel accepte forment son interface API. Une commande sous Linux peut avoir une interface API, comme il est illustré dans l’exemple de la figure 5.2. Un service REST  est une façon de créer une application Web. On communique avec le service REST à l’aide de requêtes HTTP. La requête HTTP contient l’URI vers la routine à accéder, la méthode de requête (verbe HTTP) et les paramètres de la routine, tel qu’illustré sur la figure 5.3.\nLes interfaces humain-machine (IHM), dont les interfaces graphiques, ne sont pas une interface API puisqu’elles ne peuvent être utilisées de manière logicielle. Elles permettent de faire le pont entre les utilisateurs et utilisatrices (qui communiquent par les gestes, par exemple un clic avec une souris) et l’interface API du logiciel afin d’en faciliter l’utilisation.\n\n\nPointgetX() : numbersetX(x : number)getY() : numbersetY(y : number)distance(point : Point) : numberdistance(point1 : Point, point2 : Point) : number\nFigure 5.1: Les méthodes publiques d’une classe sont un exemple d’interface API.\n\n\n\n\n$ pwd --help\npwd: pwd [-LPW]\n    Print the name of the current working directory.\n\n    Options:\n      -L        print the value of $PWD if it names the current working directory\n      -P        print the physical directory, without any symbolic links\n      -W        print the Win32 value of the physical directory\nFigure 5.2: L’interface API de la commande pwd sous Linux.\n\n\n\n\nGET https://service.com/api/v1/employee\n\nGET https://service.com/api/v1/employee/{id}\n\nPOST https://service.com/api/v1/employee\n{\n  \"name\": \"John Doe\",\n  \"rate\": 20\n}\nFigure 5.3: Exemple d’interface API d’un service REST."
  },
  {
    "objectID": "DSS.html#la-séparation-des-couches-présentation-et-domaine",
    "href": "DSS.html#la-séparation-des-couches-présentation-et-domaine",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.2 La séparation des couches présentation et domaine",
    "text": "5.2 La séparation des couches présentation et domaine\nUne des forces du DSS est qu’il fait abstraction de beaucoup de détails. Cependant, il sera nécessaire de les comprendre, car certaines règles s’imposent dans la méthodologie et on veut préparer le terrain pour expliquer pourquoi ces règles existent. En plus, dans la partie de la méthodologie où on va rentrer dans les détails (les réalisations de cas d’utilisation), il faudra maîtriser le principe de la séparation des couches présentation et domaine. Commençons par une explication de base de ce principe.\nPuisqu’il y a des acteurs humains interagissant avec le système, on doit avoir une IHM dans le système. Avec l’évolution rapide des technologies, il y a toujours eu un potentiel de concevoir des IHM de plus en plus conviviales et efficientes. Par exemple, les premières versions de Microsoft Word tournaient sur MS-DOS (PC d’IBM) au milieu des années 1980 (la souris n’était même pas nécessaire pour l’utiliser). Pourtant, le concept de style nommé (gabarit) pour les paragraphes existait, comme on le trouve dans la version de Word d’aujourd’hui.\nLes développeurs et développeuses ont appris qu’au fil du temps, les parties du code liées à l’IHM (les menus, les boutons, l’animation, etc.) sont relativement instables par rapport aux parties liées au domaine du problème (le concept de style de paragraphe). Aujourd’hui, des applications populaires sont déployées sur les plateformes mobiles, PC et Web (infonuagiques). La reconnaissance automatique de la parole  et les dispositifs haptiques  sont des exemples plus modernes de technologies qui permettent en principe une meilleure IHM.\nDonc, pour minimiser l’impact des changements de l’IHM sur tout un système, on peut comprendre l’intérêt d’isoler la partie « domaine » (qui est relativement stable) de la partie IHM (qui est différente selon la plateforme et qui a une tendance à évoluer à cause des nouvelles technologies). La conception de ces systèmes comprend un aspect important qui est la séparation des couches, notamment celle de l’IHM qu’on nomme la couche présentation et celle qui contient la logique d’affaires qu’on nomme la couche domaine. Il y a d’autres bénéfices de cette séparation, mais elle impose certaines règles qui vont à l’encontre des habitudes des développeurs et développeuses qui aiment coder rapidement.\n\n\n\n\n\n\nSans séparation des élémentsBeaucoup de couplageentre éléments de l'IHMet du domaine.IHMIHMIHMD1D2D3D4D5D6\n(a) Sans séparation, les éléments de l’IHM sont fortement couplés aux éléments de la logique de l’application. Ce genre de solution peut être créé rapidement. Cependant, si le code de l’IHM doit changer pour accommoder une nouvelle technologie, ces changements peuvent affecter le reste du système.\n\n\n\n\n\n\nBonne séparation entre couchesCouche présentationReste du système (couche domaine)Pattern Façade (GoF)réduit le couplageet favorise la séparationdes couches.IHMIHMIHMD1D2D3D4D5D6ContrôleurGRASPContrôleurGRASPopérations système(définies auDSS)\n(b) La définition et la séparation des couches présentation et domaine permettent de minimiser l’impact des changements dus aux évolutions dans les technologies liées à l’IHM et d’avoir une conception plus cohésive. Cependant, cette séparation requiert un respect de l’architecture par les développeurs et développeuses.\n\n\n\n\nFigure 5.4: Raison d’être de la séparation des couches présentation et domaine.\n\n\nLe DSS vise à modéliser l’interface API du système développé, et ce, peu importe la façon dont les utilisateurs et les utilisatrices vont interagir avec celui-ci. Lorsqu’on crée un DSS dans la méthodologie de ce manuel, on propose une conception de haut niveau qui fait un lien direct entre les besoins (les étapes d’un cas d’utilisation) et une solution qui répond à ces besoins, sans aller trop en détail (on fera cela plus tard, justement dans les RDCU), tout en respectant la séparation des couches présentation et domaine.\nVoici d’autres avantages de la séparation des couches présentation et domaine :\n\nUne forte cohésion des éléments de chaque couche, grâce à la séparation des préoccupations .\nUn faible couplage entre la couche présentation et la couche domaine.\nLa couche domaine est « protégée » des évolutions du code dans la couche présentation.\nIl peut y avoir plusieurs couches de présentation (site web, app mobile) pour la même couche domaine.\nL’interface API de la couche domaine peut être utilisé par des systèmes externes.\nLes classes cohésives peuvent être plus facilement réutilisées dans un autre projet.\nLes classes cohésives sont plus faciles à tester.\nUne séparation peut rendre l’application plus simple à comprendre (pour les nouvelles personnes dans l’équipe de développement).\n\nFinalement, l’architecture modèle-vue-contrôleur ou MVC  existe depuis 1978, et la séparation des couches en est un principe fondamental."
  },
  {
    "objectID": "DSS.html#les-dss-en-tant-quartefact",
    "href": "DSS.html#les-dss-en-tant-quartefact",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.3 Les DSS en tant qu’artefact",
    "text": "5.3 Les DSS en tant qu’artefact\nLes DSS sont expliqués en détail dans le chapitre 10 , mais voici des points importants pour la méthodologie de ce manuel :\n\nLe DSS a toujours un titre.\nL’acteur est indiqué dans la notation par un bonhomme et est représenté comme une instance de la classe du bonhomme, comme :Joueur sur la figure 5.5 (le « : » signifie une instance).\nLe Système est un objet (une instance :Système) et n’est jamais détaillé plus.\nLe but du DSS est de définir des opérations système, qui deviendront l’interface API du système ; il s’agit d’une conception de haut niveau.\nLe côté acteur du DSS n’est pas un acteur tout seul, mais une couche logicielle de présentation, comme une interface graphique ou un logiciel qui peut reconnaître la parole. Cette couche reconnaît des gestes de l’acteur et envoie une opération système. Un geste peut être un clic sur un bouton dans l’interface, une demande « Dis Siri », etc.\nPuisque la couche présentation reçoit des informations des êtres humains, les opérations système ont des arguments de type primitif. Il est difficile pour un utilisateur de spécifier une référence (pointeur en mémoire) à un objet. Alors, on peut donner le nom (de type String) d’un morceau de musique à jouer, ou spécifier une quantité (de type Integer).\nPuisque les types des arguments sont importants, on les spécifie dans les opérations système du DSS.\nUn message de retour (ligne pointillée avec flèche ouverte) vers l’acteur représente la communication des informations précises, par exemple les valeurs des dés dans l’attaque du jeu Risk. Puisque la couche présentation a beaucoup de moyens pour afficher ces informations, on ne va pas spécifier les messages de retour comme des méthodes."
  },
  {
    "objectID": "DSS.html#exemple-dss-pour-attaquer-un-pays",
    "href": "DSS.html#exemple-dss-pour-attaquer-un-pays",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.4 Exemple : DSS pour Attaquer un pays",
    "text": "5.4 Exemple : DSS pour Attaquer un pays\nLa figure 5.5 est un exemple de DSS pour le cas d’utilisation Attaquer un pays. Dans cet exemple, il y a quatre opérations système (avec les arguments de type primitif, sauf la dernière qui n’a aucun argument) et un message de retour. Vous pouvez noter tous les détails (titre, arguments, types).\n\n\n:Joueur:SystèmedémarrerAttaque(paysAttaquant : String,paysDéfenseur : String)loop[pas terminé]annoncerAttaque(nbRégimentsAttaquant : int)annoncerDéfense(nbRégimentsDéfenseur : int)résultats des deux lancers, régiments perdusde l'attaquant et du défenseur le cas échéantterminerAttaque()\nFigure 5.5: Diagramme de séquence système pour le scénario Attaquer un pays."
  },
  {
    "objectID": "DSS.html#les-dss-font-abstraction-de-la-couche-présentation",
    "href": "DSS.html#les-dss-font-abstraction-de-la-couche-présentation",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.5 Les DSS font abstraction de la couche présentation",
    "text": "5.5 Les DSS font abstraction de la couche présentation\nLe but du DSS est de se concentrer sur l’interface API (les opérations système) de la solution. Dans ce sens, c’est une conception de haut niveau. Le « Système » est modélisé comme une boîte noire. Par exemple, sur la figure 5.6, il y a l’acteur, le Système et une opération système. On ne rentre pas dans les détails, bien qu’ils existent et soient importants.\n\n\n:Joueur:SystèmedémarrerAttaque(...)\nFigure 5.6: Une opération système dans un DSS. C’est une abstraction.\n\n\nPlus tard, lorsque c’est le moment d’implémenter le code, les détails importants devront être respectés. Il faut faire attention aux principes de la séparation des couches présentation et domaine. Par exemple, la figure 5.7 rentre dans les détails de ce qui se passe réellement dans une opération système quand la solution fonctionne avec un service Web :\n\nD’abord, l’acteur clique sur un bouton ;\nCe clic se transforme en appel REST ;\nUn routeur transforme l’appel REST en une opération système envoyée à un contrôleur GRASP. Notez que c’est un objet du domaine qui reçoit l’opération système – c’est l’essence du principe GRASP Contrôleur ;\nLe contrôleur GRASP dirige la suite, selon la solution proposée dans la réalisation de cas d’utilisation (RDCU).\n\n\n\nCouche présentationCouche domaine:Joueur« NavigateurWeb »:Button« NodeExpress »:Routeur« ContrôleurGRASP »:JeuRisk...cliquerHTTP GET/api/v1/démarrerAttaque/...Router handler (Express)démarrerAttaqueOpération système définie dans DSSdémarrerAttaque(...)...selon la RDCU\nFigure 5.7: Une opération système est envoyée par la couche présentation et elle est reçue dans la couche domaine par son contrôleur GRASP. Ceci est un exemple avec un navigateur Web, mais d’autres possibilités existent pour la couche présentation.\n\n\n\n\n\n\n\n\nLa figure 5.7 est à titre d’information seulement. Un DSS ne rentre pas dans tous ces détails."
  },
  {
    "objectID": "DSS.html#faq-dss",
    "href": "DSS.html#faq-dss",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.6 FAQ DSS",
    "text": "5.6 FAQ DSS\n\n5.6.1 Faut-il une opération système après une boucle ?\n\n\n\n\n\n\nDans l’exemple pour Attaquer un pays (figure 5.5), à l’extérieur de la boucle, il y a une opération système terminerAttaque. Est-ce obligatoire d’avoir une opération système après une boucle ?\n\n\n\nL’opération système terminerAttaque sert à signaler la fin de la boucle. Le système saura que l’acteur ne veut plus répéter les actions dans la boucle. Mais elle permet aussi de faire des calculs concernant ce qui s’est passé dans la boucle, par exemple pour déterminer qui contrôle quel pays après les attaques.\nCependant, si vous avez une boucle pour indiquer la possibilité de répéter une action (par exemple ajouter des produits dans un système d’inventaire) et que vous n’avez pas besoin de faire un calcul à la fin, alors une opération système pour terminer une telle boucle n’est pas nécessaire (surtout avec une application Web).\n\n\n5.6.2 Comment faire si un cas d’utilisation a des scénarios alternatifs ?\n\n\n\n\n\n\nFait-on plusieurs DSS (un pour chaque scénario alternatif) ou utilise-t-on la notation UML (des blocs opt et alt) pour montrer des flots différents dans le même DSS ?\n\n\n\nUn objectif derrière le DSS est de définir les opérations système. Donc, on peut se poser la question suivante : les scénarios alternatifs impliquent-ils une ou plusieurs opérations système n’ayant pas encore été définies ? Si la réponse est non, on peut ignorer les scénarios alternatifs dans le DSS. Par contre, si la réponse est oui, il est essentiel de définir ces opérations système dans un DSS.\nQuant au choix de faire des DSS séparés ou d’utiliser la notation UML pour montrer les flots différents dans le même DSS, ça dépend de la complexité de la logique des flots. Un DSS devrait être facile à comprendre. C’est à vous de juger si votre DSS avec des opt ou des alt est assez simple ou est compliqué à lire. Utilisez un autre DSS (ou plusieurs) ayant le nom des scénarios alternatifs si cela vous semble plus clair.\n\n\n5.6.3 Est-ce un bon design d’avoir une opération système avec beaucoup d’arguments (de type primitif) ?\n\n\n\n\n\n\nSelon la méthodologie, une opération système doit avoir seulement des arguments de type primitif. À cause de ça, j’ai plusieurs opérations système avec de nombreux (plus de cinq) arguments. Par exemple, pour créer un Devoir (dans le projet du laboratoire), il y a beaucoup d’informations provenant du formulaire Web et on doit les passer toutes à l’opération système. Pourquoi n’est-il pas permis d’instancier un objet de Devoir d’abord et le passer comme un seul argument ?\n\n\n\nIl y a deux volets à cette question.\n\nIl y a le problème de beaucoup d’arguments (de type primitif) pour une opération système. Cela peut arriver, surtout pour les opérations sur les objets du domaine (comme le Devoir) qui ont beaucoup d’attributs. En effet, il n’est pas convivial d’avoir beaucoup d’arguments dans un appel (une opération).\nEnsuite, il n’est pas conseillé de passer des objets du domaine (par exemple, le Devoir) comme arguments, puisque c’est la couche présentation qui invoque l’opération système. La couche présentation n’est pas censée manipuler directement les objets dans la couche domaine, sinon elle empiète sur les responsabilités de la couche domaine.\n\nUne solution pour réduire le nombre d’arguments sans utiliser un objet du domaine est d’appliquer un réusinage pour le smell nommé Long Parameter List, par exemple Introduce Parameter Object. Notez que l’objet de paramètre que vous introduisez n’est pas un objet (classe) du domaine ! La distinction est importante, car la logique d’affaires demeure dans la couche domaine. En TypeScript, une fonction peut être définie avec un objet de paramètre. Cet exemple montre même comment on peut « déstructurer » l’objet pour déclarer les variables utilisées dans la fonction :\n// La fonction n'a qu'un seul argument (un objet de paramètre).\n// Exemple inspiré de https://leanpub.com/essentialtypescript/read#destructuring\nfunction compteARebours({ initial: number, final: final = 0,\n                          increment: increment = 1, initial: actuel }) {\n    while (actuel >= final) {\n        console.log(actuel);\n        actuel -= increment\n    }\n}\ncompteARebours({ initial: 20 });  // on passe un objet de paramètre\ncompteARebours({ initial: 20, increment: 2, final: 4 });\nPasser un objet de paramètre à une opération système respecte la séparation des couches (la modularité) et augmente la lisibilité du code.\n\n\n5.6.4 Ne serait-il pas plus simple de passer l’objet body de la page Web au contrôleur GRASP ?\n\n\n\n\n\n\nDécortiquer toutes les informations dans un formulaire Web est compliqué, puis on doit passer tout ça à un contrôleur GRASP comme des arguments de type primitif. Ne serait-il pas plus simple de passer l’objet body de la page Web au contrôleur GRASP et de le laisser faire le décorticage ?\n\n\n\nDans un sens, ça serait plus simple (pour le code de la couche présentation). Cependant, on veut séparer les couches pour favoriser le remplacement de la couche présentation, par exemple à travers une application iOS ou Android.\nSi vous mettez la logique de la couche présentation (décortiquer un formulaire Web) dans la couche domaine (le contrôleur GRASP), ça ne respecte pas les responsabilités des couches. Imaginez un tel contrôleur GRASP si vous aviez trois types d’applications frontales (navigateur Web, application iOS et application Android). Le contrôleur GRASP recevra des représentations de « formulaire » de chaque couche présentation différente. En passant, l’objet body n’a rien à voir avec une interface Android ! Ce pauvre contrôleur serait alors obligé de connaître toutes les trois formes (Web, iOS, Android) et, ainsi, sa cohésion serait beaucoup plus faible. Pour respecter les responsabilités, on laisse la couche présentation faire le décorticage et construire une opération système selon l’interface API définie dans le DSS. Cela simplifie aussi le contrôleur GRASP."
  },
  {
    "objectID": "DSS.html#exercices",
    "href": "DSS.html#exercices",
    "title": "5  Diagrammes de séquence système (DSS)",
    "section": "5.7 Exercices",
    "text": "5.7 Exercices\n\n\n\n\n\n\nNote\n\n\n\nVous pouvez dessiner les diagrammes à la main et en prendre une photo avec une application comme Microsoft Lens (Android, iOS).\nVous pouvez également utiliser PlantUML. Voici des ressources à ce propos : \n\ntutoriel VS Code sur YouTube \nextension PlantUML pour VS Code ;\nPlantUML Gizmo, module supplémentaire Google Docs ;\nPlantText.com.\n\nMéfiez-vous des outils comme Lucidchart ayant seulement des profils superficiels (sans règles) pour l’UML. Voir la figure 13.5 pour plus de détails.\n\n\n\nExercice 5.1 (Dessiner un DSS à partir d’un cas d’utilisation) Esquissez le DSS pour le cas d’utilisation Réserver un livre de la bibliothèque. Toutes les opérations système doivent définir le type de chaque argument, si nécessaire."
  },
  {
    "objectID": "GRASP.html#sec-SpectreDeLaConception",
    "href": "GRASP.html#sec-SpectreDeLaConception",
    "title": "6  Principes GRASP",
    "section": "6.1 Spectre de la conception",
    "text": "6.1 Spectre de la conception\nNeal Ford (2009) a proposé la notion d’effort pour la conception qu’il a nommée le « Spectre de la conception ». La figure 6.1 illustre le principe.\n\n\n[« Hacking cowboy »+Agile]« Cascade pure »\nFigure 6.1: Spectre de la conception (Ford, 2009).\n\n\nÀ une extrémité, il y a la mentalité de mettre presque zéro effort pour une conception, que l’on nomme « hacking cowboy ». C’est le cas d’un hackathon (un marathon de programmation durant 24 ou 48 heures où il faut produire une solution rapidement), au cours duquel vous ne feriez pas un logiciel avec 10 patterns GoF et vous ne feriez pas non plus les diagrammes UML pour réfléchir à votre architecture. Vous savez aussi que le code produit lors d’un hackathon ne sera pas facile à maintenir. Le seul but de cette activité est de développer du code qui marche pour montrer une idée intéressante.\nUne situation similaire s’applique à certains contextes d’entreprise, par exemple une entreprise en démarrage qui a seulement un financement pour six mois. Si une solution de « produit minimum viable » (MVP en anglais)  n’existe pas à la fin de la période de financement, l’entreprise n’existera plus, car il n’y aura pas une seconde période de financement. Si, par contre, l’entreprise est financée pour une seconde période, la conception du code pourrait avoir besoin de beaucoup de soin et de maintenance, car elle aura été préalablement négligée. Cette négligence de la conception (pour la maintenabilité) est aussi nommée la dette technique.\nÀ l’autre extrémité du spectre de la conception, on retrouve ce que l’on nomme « Cascade pure », où beaucoup d’effort a été déployé pour la conception. Dans le cycle de vie en cascade, on met un temps fixe (par exemple plusieurs mois) à étudier la conception. Comme toute chose poussée à l’extrême, ce n’est pas idéal non plus. Dans son livre, Larman (2005) explique en détail des problèmes posés par une approche en cascade. En dépit des problèmes dus à l’approche en cascade, elle est encore utilisée dans certains domaines, par exemple les logiciels pour le contrôle d’avions ou le contrôle d’appareils médicaux. La sécurité et la robustesse des logiciels sont très importantes, alors on passe beaucoup de temps à vérifier et à valider la conception. Puisque les exigences sont plus stables (et que les développeurs et les développeuses ont a priori une meilleure compréhension du domaine), l’approche en cascade n’est pas si mal. Pourtant, le coût pour produire des logiciels certifiés est énorme.\nLe spectre de la conception est très important pour le monde réel, parce qu’une ingénieure ou un ingénieur devrait pouvoir s’adapter selon les attentes de son travail. Le dogme sur « la bonne manière » de développer un logiciel est souvent sans contexte. C’est le contexte de l’entreprise pour laquelle vous travaillez qui peut quantifier les efforts à mettre sur la conception. Cependant, méfiez-vous des entreprises qui ne portent aucune attention à la conception (l’extrémité « hacking cowboy » du spectre), même si l’on vous dit que c’est « agile »."
  },
  {
    "objectID": "GRASP.html#tbl-GRASPTable",
    "href": "GRASP.html#tbl-GRASPTable",
    "title": "6  Principes GRASP",
    "section": "6.2 Tableau des principes GRASP",
    "text": "6.2 Tableau des principes GRASP\nVoici un extrait du livre de Larman (2005).\n\n\n\n\nTableau 6.1: Patterns (principes) GRASP\n\n\n\n\n\n\nPattern\nDescription\n\n\n\n\nExpert en Information\nF16.11/A17.11 \nUn principe général de conception d’objets et d’affectation des responsabilités.\nAffectez une responsabilité à l’expert – la classe qui possède les informations nécessaires pour s’en acquitter.\n\n\nCréateur\nF16.10/A17.10 \nQui crée ? (Notez que Fabrique Concrète est une solution de rechange courante.)\nAffectez à la classe B la responsabilité de créer une instance de la classe A si l’une des assertions suivantes est vraie :\n\nB contient A\nB agrège A [à favoriser]\nB a les données pour initialiser A\nB enregistre A\nB utilise étroitement A\n\n\n\nContrôleur\nF16.13/A17.13 \nQuel est le premier objet en dehors de la couche présentation qui reçoit et coordonne (« contrôle ») les opérations système ?\nAffectez une responsabilité à la classe qui correspond à l’une de ces définitions :\n\n[Contrôleur de façade] [Cette classe] représente le système global, un « objet racine », un équipement ou un sous-système (contrôleur de façade).\n[Contrôleur de session] [Cette classe] représente un scénario de cas d’utilisation dans lequel l’opération système se produit (contrôleur de session ou contrôleur de cas d’utilisation). [On la nomme GestionnaireX, où X est le nom du cas d’utilisation.]\n\n\n\nFaible Couplage\n(évaluation)\nF16.12/A17.12 \nComment minimiser les dépendances ?\nAffectez les responsabilités de sorte que le couplage (inutile) demeure faible. Employez ce principe pour évaluer les alternatives.\n\n\nForte Cohésion\n(évaluation)\nF16.14/A17.14 \nComment conserver les objets cohésifs, compréhensibles, gérables et, en conséquence, obtenir un Faible Couplage ?\nAffectez les responsabilités de sorte que les classes demeurent cohésives. Employez ce principe pour évaluer les différentes solutions.\n\n\nPolymorphisme\nF22.1/A25.1 \nQui est responsable quand le comportement varie selon le type ?\nLorsqu’un comportement varie selon le type (classe), affectez la responsabilité de ce comportement – avec des opérations polymorphes – aux types selon lesquels le comportement varie.\n\n\nFabrication Pure F22.2/A25.2 \nEn cas de situation désespérée, que faire quand vous ne voulez pas transgresser les principes de Faible Couplage et de Forte Cohésion ?\nAffectez un ensemble très cohésif de responsabilités à une classe « comportementale » artificielle qui ne représente pas un concept du domaine — une entité fabriquée pour augmenter la cohésion, diminuer le couplage et faciliter la réutilisation.\n\n\nIndirection\nF22.3/A25.3 \nComment affecter les responsabilités pour éviter le couplage direct ?\nAffectez la responsabilité à un objet qui sert d’intermédiaire avec les autres composants ou services.\n\n\nProtection des Variations\nF22.4/A25.4 \nComment affecter les responsabilités aux objets, sous-systèmes et systèmes de sorte que les variations ou l’instabilité de ces éléments n’aient pas d’impact négatif sur les autres ?\nIdentifiez les points de variation ou d’instabilité prévisibles et affectez les responsabilités afin de créer une « interface » stable autour d’eux."
  },
  {
    "objectID": "GRASP.html#grasp-et-rdcu",
    "href": "GRASP.html#grasp-et-rdcu",
    "title": "6  Principes GRASP",
    "section": "6.3 GRASP et RDCU",
    "text": "6.3 GRASP et RDCU\nLes principes GRASP sont utilisés dans les réalisations de cas d’utilisation (RDCU). On s’en sert pour annoter les décisions de conception, pour rendre explicites (documenter) les choix. Voir la section Réalisations de cas d’utilisation (RDCU) pour plus d’informations."
  },
  {
    "objectID": "GRASP.html#grasp-et-patterns-gof",
    "href": "GRASP.html#grasp-et-patterns-gof",
    "title": "6  Principes GRASP",
    "section": "6.4 GRASP et patterns GoF",
    "text": "6.4 GRASP et patterns GoF\nOn peut voir les principes GRASP comme des généralisations (principes de base) des patterns GoF. Voir la section Décortiquer les patterns GoF avec GRASP pour plus d’informations."
  },
  {
    "objectID": "GRASP.html#exercices",
    "href": "GRASP.html#exercices",
    "title": "6  Principes GRASP",
    "section": "6.5 Exercices",
    "text": "6.5 Exercices\n\nExercice 6.1 (GRASP Polymorphisme) Soit le diagramme de classe sur la figure 6.2 modélisant l’exemple de Fowler (2018) à Replace Conditional with Polymorphism.\n\n\nBirdtype : StringnumberOfCoconuts : numbervoltage : numbergetPlumage() : String\nFigure 6.2: Classe « Bird » à laquelle on peut appliquer le principe GRASP Polymorphisme.\n\n\nAppliquez le GRASP Polymorphisme pour le code suivant :\nget plumage() {\n    switch (this.type) {\n        case 'EuropeanSwallow':\n            return \"average\";\n        \n        case 'AfricanSwallow':\n            return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";\n        \n        case 'NorwegianBlueParrot':\n            return (this.voltage > 100) ? \"scorched\" : \"beautiful\";\n        \n        default:\n            return \"unknown\";\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nPuisque le comportement de getPlumage change en fonction du type de l’oiseau, il est préférable de créer une classe concrète pour chaque oiseau (EuropeanSwallow, AfricanSwallow, NorwegianBlueParrot) afin d’améliorer la cohésion du code. L’utilisation d’une classe abstraite Bird permet de garder un faible couplage malgré l’ajout de plusieurs nouvelles classes. Par le principe de polymorphisme, les oiseaux concrets sont aussi considérés comme des Bird. Puisque les oiseaux ne partagent pas de propriétés ou d’implémentation, il aurait aussi été possible d’utiliser une interface pour la classe Bird.\n\n\nBirdgetPlumage() : StringEuropeanSwallowAfricanSwallownumberOfCoconuts : numberNorwegianBlueParrotvoltage : number\nFigure 6.3: Classes « Bird » auxquelles on a appliqué le principe GRASP Polymorphisme.\n\n\nabstract class Bird {\n    abstract get plumage(): string\n}\n\nclass EuropeanSwallow extends Bird {\n    get plumage() {\n        return \"average\" \n    }\n}\n\nclass AfricanSwallow extends Bird {\n    _numberOfCoconuts: number;\n\n    constructor(numberOfCoconuts: number) {\n        super();\n        this._numberOfCoconuts = numberOfCoconuts;\n    }\n  \n    get plumage() {\n        return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";\n    }\n\n    get numberOfCoconuts() {\n        return this._numberOfCoconuts;\n    }\n}\n\nclass NorwegianBlueParrot extends Bird {\n    _voltage: number;\n\n    constructor(voltage: number) {\n        super();\n        this._voltage = voltage;\n    }\n\n    get plumage() {\n        return (this.voltage > 100) ? \"scorched\" : \"beautiful\";\n    }\n\n    get voltage() {\n        return this._voltage;\n    }\n}\n\n\n\n\n\n\nExercice 6.2 (GRASP Contrôleur, Fabrication Pure et Indirection)  \n\nExpliquez pourquoi le principe du GRASP Contrôleur dans le cas d’un contrôleur de session (de cas d’utilisation) est une Fabrication Pure.\nSoit un contrôleur de session GestionnaireVentes ; quelle est la « situation désespérée » qui est mitigée par ce contrôleur ? Astuce : relire la définition de Fabrication Pure.\nExpliquez pourquoi le principe du GRASP Contrôleur dans le cas d’un contrôleur de session est un exemple du GRASP Indirection.\n\n\n\nExercice 6.3 (GRASP Expert en Information et Forte Cohésion) Appliquez le GRASP Expert en Information pour améliorer la conception des classes dans le code suivant :\nclass Point {\n    x:number;\n    y:number;\n\n    constructor(x:number, y:number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Circle {\n    center:Point;\n    radius:number;\n\n    constructor(center:Point, radius:number) {\n        this.center = center;\n        this.radius = radius\n    }\n}\n\nclass SomeClass {\n    someMethod() {\n        const center = new Point(0, 12);\n        const c = new Circle(center, 14);\n        \n        const area = Math.PI * c.radius* c.radius;\n        const diameter = c.radius * 2;\n        const circumference = Math.PI * c.radius * 2;\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nPuisque la classe Circle possède les informations nécessaires (radius) pour calculer area, diameter et circumference, c’est elle qui doit contenir les méthodes pour calculer ces propriétés. Cela augmente la cohésion de la classe SomeClass puisqu’elle a moins de responsabilités. La complétude de la classe Circle est améliorée et ses méthodes peuvent être testées et réutilisées dans d’autres classes.\nPour être concis, la classe Point est omise puisqu’aucune modification n’y est apportée.\nclass Circle {\n    center:Point;\n    radius:number;\n\n    constructor(center:Point, radius:number) {\n        this.center = center;\n        this.radius = radius\n    }\n\n    get area():number {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    get diameter():number {\n        return this.radius * 2;\n    }\n\n    get circumference():number {\n        return Math.PI * this.radius * 2;\n    }\n}\n\nclass SomeClass {\n    someMethod() {\n        const center = new Point(0, 12);\n        const c = new Circle(center, 14);\n        \n        const area = c.area;\n        const diameter = c.diameter;\n        const circumference = c.circumference;\n    }\n}\n\n\n\n\n\nExercice 6.4 (GRASP Fabrication Pure et Indirection) Appliquez le GRASP Fabrication Pure au contrôleur BirdManager pour améliorer sa cohésion. Ajoutez une fabrique de Bird à qui le contrôleur pourra déléguer la responsabilité de créer les objets Bird. Par la suite, expliquez pourquoi la fabrique que vous avez ajoutée est un exemple des GRASP Indirection et Fabrication Pure.\nclass BirdManager {\n    addBird(b: {type: String, numberOfCoconuts: number, voltage: number}) {\n        let bird: Bird;\n\n        if (b.type == \"EuropeanSwallow\") {\n            bird = new EuropeanSwallow();\n        }\n        else if (b.type == \"AfricanSwallow\") {\n            bird = new AfricanSwallow(b.numberOfCoconuts);\n        }\n        else if (b.type == \"NorwegianBlueParrot\") {\n            bird = new NorwegianBlueParrot(b.voltage)\n        }\n        else {\n            throw new Error(\"Unsupported bird.\");\n        }\n\n        // Then, we do something with the bird...\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nL’ajout de la fabrique BirdFactory permet d’améliorer la cohésion du contrôleur BirdManager puisque ses responsabilités sont réduites. La fabrique est un exemple du GRASP Indirection puisqu’elle élimine le couplage direct entre le contrôleur BirdManager et les différents types de Bird. Si d’autres types de Bird sont ajoutés à l’application, l’impact sera moins important sur le contrôleur. La fabrique est une Fabrication Pure, car elle n’existe pas dans le domaine de l’application. Elle a été inventée pour améliorer la cohésion de BirdManager et réduire son couplage avec les Bird concrets.\nclass BirdManager {\n    addBird(b: {type: String, numberOfCoconuts: number, voltage: number}) {\n        let bird: Bird = BirdFactory.createBird(b);\n\n        // Then, we do something with the bird...\n    }\n}\n\nclass BirdFactory {\n    public static createBird(b: {type: String, numberOfCoconuts: number, \n                             voltage: number}) {\n        let bird: Bird;\n\n        if (b.type == \"EuropeanSwallow\") {\n            bird = new EuropeanSwallow();\n        }\n        else if (b.type == \"AfricanSwallow\") {\n            bird = new AfricanSwallow(b.numberOfCoconuts);\n        }\n        else if (b.type == \"NorwegianBlueParrot\") {\n            bird = new NorwegianBlueParrot(b.voltage)\n        }\n        else {\n            throw new Error(\"Unsupported bird.\");\n        }\n\n        return bird;\n    }\n}\n\n\n\n\n\nExercice 6.5 (GRASP Expert en Information et Forte Cohésion) Appliquez le GRASP Expert en Information aux classes Movie, Person et MovieManager pour améliorer leur cohésion. Pour être concis, les constructeurs, les accesseurs et les mutateurs des classes Movie et Person sont omis.\nclass Movie {\n    _id:String\n    _title:String\n    _synopsis:String\n    _year:number\n    _duration:number\n    _genres:String[]\n    _directors:Person[]\n}\n\nclass Person {\n    _name:String\n    _biography:String\n}\n\nclass MovieManager {\n    public getMovie(String id) {\n        const movie:Movie = movies.get(id); // We get the movie from the map\n\n        // We convert the movie to JSON\n        var movieJSON = {\n            id: movie.id,\n            title: movie.title,\n            synopsis: movie.synopsis,\n            year: movie.year,\n            duration: movie.duration,\n            genres: movie.genres,\n            directors: []\n        };\n\n        // We convert the directors to JSON and we add them to JSON representation of the movie\n        for (var director:Person of movie.directors) {\n            var directorJSON = {\n                name: director.name,\n                biography: director.biography\n            };\n\n            movieJSON.directors.append(directorJSON);\n        }\n\n        return movieJSON;\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nPuisque les classes Movie et Person possèdent les informations nécessaires pour se convertir en JSON, ce sont elles qui doivent posséder les méthodes pour effectuer la conversion. Cela augmente la cohésion de la classe MovieManager puisqu’elle a moins de responsabilités. La complétude des classes Movie et Person est améliorée et leurs méthodes peuvent être testées et réutilisées dans d’autres classes.\nclass Movie {\n    _id:String\n    _title:String\n    _synopsis:String\n    _year:number\n    _duration:number\n    _genres:String[]\n    _directors:Person[]\n\n    public toJSON() {\n        return {\n            id: this._id,\n            title: this._title,\n            synopsis: this._synopsis,\n            year: this._year,\n            duration: this._duration,\n            genres: this._genres,\n            directors: this._directors // The conversion to JSON will be done automatically\n        };\n    }\n}\n\nclass Person {\n    _name:String\n    _biography:String\n\n    public toJSON() {\n        return {\n            name: this._name,\n            biography: this._biography\n        };\n    }\n}\n\nclass MovieManager {\n    public getMovie(id:String) {\n        const movie:Movie = movies.get(id); // We get the movie from the map\n\n        return movie.toJSON();\n    }\n}\n\n\n\n\n\nExercice 6.6 (GRASP Expert en Information et Forte Cohésion) Appliquez le GRASP Expert en information aux classes Book et BookManager pour améliorer leur cohésion. Pour être concis, les accesseurs et les mutateurs de la classe Book sont omis.\nclass Book {\n    _title:String\n    _year:number\n    _pages:number\n    _isbn:String\n\n    constructor(title:String, year:number, pages:number, isbn:String) {\n        this._title = title;\n        this._year = year;\n        this._pages = pages;\n        this._isbn = isbn;\n    }\n}\n\nclass BookManager {\n    public addBook(title:String, year:number, pages:number, isbn:String) {\n        title = title.trim();\n        year = parseInt(year);\n        pages = parseInt(pages);\n        isbn = isbn.trim();\n\n        if (title.length == 0) {\n            throw new Error(\"The book title must not be empty.\");\n        }\n\n        if (year > (new Date()).getFullYear()) {\n            throw new Error(\"You cannot add a book that will be published in the future.\");\n        }\n\n        if (pages <= 0) {\n            throw new Error(\"The book must contain at least one page.\");\n        }\n\n        if (!(isbn.length == 10 || isbn.length == 13)) {\n            throw new Error(\"ISBN must have 10 or 13 characters.\");\n        }\n\n        const book = new Book(title, year, pages, isbn);\n\n        // We add the book to the map\n        books.add(isbn, book);\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nPuisque la classe Book contient les propriétés title, year, pages et isbn, c’est sa responsabilité de déterminer ce qui est une information erronée et d’effectuer les validations. Cela augmente la cohésion de la classe BookManager puisqu’elle a moins de responsabilités. De plus, si on doit à modifier les informations d’une livre existant, il ne sera pas nécessaire de dupliquer les validations. La complétude de la classe Book est améliorée et les validations peuvent être testées à l’aide de tests unitaires.\nclass Book {\n    _title:String\n    _year:number\n    _pages:number\n    _isbn:String\n\n    constructor(title:String, year:number, pages:number, isbn:String) {\n        this._title = title;\n        this._year = year;\n        this._pages = pages;\n        this._isbn = isbn;\n    }\n\n    public get title() {\n        return this._title;\n    }\n\n    public set title(title:String) {\n        title = title.trim();\n\n        if (title.length == 0) {\n            throw new Error(\"The book title must not be empty.\");\n        }\n\n        this._title = title;\n    }\n\n    public get year() {\n        return this._year;\n    }\n\n    public set year(year:number) {\n        year = parseInt(year);\n\n        if (year > (new Date()).getFullYear()) {\n            throw new Error(\"You cannot add a book that will be published in the future.\");\n        }\n\n        this._year = year;\n    }\n\n    public get pages() {\n        return this._pages;\n    }\n\n    public set pages(pages:number) {\n        pages = parseInt(pages);\n\n        if (pages <= 0) {\n            throw new Error(\"The book must contain at least one page.\");\n        }\n\n        this._pages = pages;\n    }\n\n    public get isbn() {\n        return this._isbn;\n    }\n\n    public set isbn(isbn:String) {\n        isbn = isbn.trim();\n        \n        if (!(isbn.length == 10 || isbn.length == 13)) {\n            throw new Error(\"ISBN must have 10 or 13 characters.\");\n        }\n\n        this._isbn = isbn;\n    }\n}\n\nclass BookManager {\n    public addBook(title:String, year:number, pages:number, isbn:String) {\n        const book = new Book(title, year, pages, isbn);\n\n        // We add the book to the map\n        books.add(isbn, book);\n    }\n}\n\n\n\n\n\nExercice 6.7 (GRASP Polymorphisme, Créateur, Fabrication Pure et Indirection) Appliquez les GRASP Polymorphisme et Créateur à la classe PartManager pour améliorer sa cohésion et réduire son couplage. Créez une interface PartParser qui contient les méthodes pertinentes aux parsers et qui sera implémentée par ces derniers. Ajoutez un PartParser concret pour chaque type de fichier traitée par la méthode parsePart. Ajoutez une fabrique de PartParser à qui PartManager pourra déléguer la responsabilité de créer les objets PartParser. Par la suite, expliquez pourquoi la fabrique que vous avez ajoutée est un exemple des GRASP Indirection et Fabrication Pure.\nclass Part {\n    name:string\n    description:String\n\n    constructor(name:string, description:String) {\n        this.name = name;\n        this.description = description;\n    }\n}\n\nclass PartManager {\n    public parsePart(fileType:string, content:string) {\n        var part:Part;\n\n        if (fileType == \"csv\") {\n            const partsInfo = content.split(\",\");\n\n            part = new Part(partsInfo[0], partsInfo[1]);\n        }\n        else if (fileType == \"json\") {\n            const part = JSON.parse(content);\n\n            part = new Part(part.name, part.description);\n        }\n        else if (fileType == \"xml\") {\n            var parser = new DOMParser();\n            var xml = parser.parseFromString(content, \"application/xml\");\n\n            var name = xml.getElementsByTagName(\"name\")[0].childNodes[0].nodeValue || \"\"; // Return an empty name if it is not in the XML tree\n            var description = xml.getElementsByTagName(\"description\")[0].childNodes[0].nodeValue || \"\"; // Return an empty description if it is not in the XML tree\n\n            part = new Part(name, description);\n        }\n        else {\n            throw new Error(\"Unsupported file type\");\n        }\n\n        // Then, we do something with the part...\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nLa création de plusieurs PartParser permet d’améliorer la cohésion de la classe PartManager puisqu’elle a moins de responsabilités. Les PartParser peuvent être plus facilement réutilisés et testés à l’aide de tests unitaires. La création de l’interface PartParser permet de créer un API stable pour les PartParser, ce qui réduit le couplage entre PartManager et les différents types de PartParser. La fabrique est un exemple du GRASP Indirection puisqu’elle élimine le couplage direct entre la classe PartManager et les différents types de PartParser. Si d’autres types de PartParser sont ajoutés à l’application, l’impact sera moins important sur le contrôleur. La fabrique est une Fabrication Pure, car elle n’existe pas dans le domaine de l’application. Elle a été inventée pour améliorer la cohésion de PartManager et réduire son couplage avec les PartParser concrets.\nclass Part {\n    name:string\n    description:String\n\n    constructor(name:string, description:String) {\n        this.name = name;\n        this.description = description;\n    }\n}\n\nclass PartManager {\n    public parsePart(fileType:string, content:string) {\n        var part:Part = ParserFactory.createParser(fileType, content).parse();\n\n        // Then, we do something with the part...\n    }\n}\n\ninterface PartParser {\n    public parse():Part\n}\n\nclass CSVPartParser implements PartParser {\n    public parse():Part {\n        const partsInfo = content.split(\",\");\n\n        return new Part(partsInfo[0], partsInfo[1]);\n    }\n}\n\nclass JSONPartParser implements PartParser {\n    public parse():Part {\n        const part = JSON.parse(content);\n\n        return new Part(part.name, part.description);\n    }\n}\n\nclass XMLPartParser implements PartParser {\n    public parse():Part {\n        var parser = new DOMParser();\n        var xml = parser.parseFromString(content, \"application/xml\");\n\n        var name = xml.getElementsByTagName(\"name\")[0].childNodes[0].nodeValue || \"\"; // Return an empty name if it is not in the XML tree\n        var description = xml.getElementsByTagName(\"description\")[0].childNodes[0].nodeValue || \"\"; // Return an empty description if it is not in the XML tree\n\n        return new Part(name, description);\n    }\n}\n\nclass ParserFactory {\n    public static createParser(fileType:string, content:string) {\n        if (fileType == \"csv\") {\n            return new CSVPartParser(content);\n        }\n        else if (fileType == \"json\") {\n            return new JSONPartParser(content);\n        }\n        else if (fileType == \"xml\") {\n            return new XMLPartParser(content);\n        }\n        else {\n            throw new Error(\"Unsupported file type\");\n        }\n    }\n}\n\n\n\n\n\nExercice 6.8 (GRASP Protection des Variations et Fabrication Pure) Le code suivant permet de gérer les emprunts de livres pour une bibliothèque. À chaque emprunt un événement est ajouté dans le calendrier Google de l’emprunteur pour lui rappeler de retourner le livre à temps. Pour ce faire, l’API de Google Calendar est utilisé. Appliquez les GRASP Protection des Variations et Fabrication Pure pour améliorer la cohésion de ReservationManager. Pour être concis, la gestion des réservations dans l’application est omise.\nclass ReservationManager {\n    public addReservation(String memberId, String bookId, String bookCopyId, Date expiration) {\n        var member = members.get(memberId);\n        var book = books.get(bookId);\n        \n        // We assume that we create the reservation for the member some way...\n\n        // Then we add an event to the Google Calendar of the member to remind them to return their book\n        var dateAsString = expiration.toLocaleDateString(\"fr-CA\", {year: \"numeric\", month: \"2-digit\", day: \"2-digit\"});\n        \n        // References\n        // https://developers.google.com/calendar/api/v3/reference?hl=fr\n        // https://dev.to/pedrohase/create-google-calender-events-using-the-google-api-and-service-accounts-in-nodejs-22m8\n        var event = {\n            \"summary\": `Your reservation for ${book.getTitle()} is expired`,\n            \"location\": \"475 Boul. de Maisonneuve E, Montréal, QC H2L 5C4\",\n            \"description\": \"You must return your book today to avoid late fees.\",\n            \"start\": {\n                \"date\": dateAsString,\n                \"timeZone\": \"America/Toronto\"\n            },\n            \"end\": {\n                \"date\": dateAsString,\n                \"timeZone\": \"America/Toronto\"\n            },\n            \"reminders\": {\n                \"useDefault\": false,\n                \"overrides\": [\n                    // Send a reminder the day before by email and push notification\n                    {\"method\": \"email\", \"minutes\": 24 * 60},\n                    {\"method\": \"popup\", \"minutes\": 24 * 60}\n                ]\n            }\n        };\n\n        // Create a client that we can use to communicate with Google \n        const client = new JWT({\n            email: member.email,\n            key: member.googlePrivateKey,\n            scopes: [\n                \"https://www.googleapis.com/auth/calendar\",\n                \"https://www.googleapis.com/auth/calendar.events\",\n            ],\n        });\n\n        const calendar = google.calendar({ version: \"v3\" });\n\n        // We make a request to Google Calendar API.\n        const res = await calendar.events.insert({\n            calendarId: \"primary\",\n            auth: client,\n            requestBody: event,\n        });\n    }\n}\n\n\n\n\n\n\nVoici une solution\n\n\n\n\n\nLa classe GoogleCalendar est une Fabrication Pure, car elle n’existe pas dans le domaine de l’application. Elle a été ajoutée pour améliorer la cohésion de ReservationManager. Avec la classe GoogleCalendar, il est aussi plus facile de réutiliser la fonctionnalité dans une autre partie de l’application. Selon le GRASP Protection des Variations, la classe GoogleCalendar permet aussi de réduire le couplage entre ReservationManager et l’interface API de Google. Si Google apporte des changements à son interface API, l’impact sur la classe ReservationManager sera moins important.\nPour améliorer la cohésion de la classe ReservationManager, est-il possible de donner la responsabilité de créer l’objet event à une autre classe ?\nIl serait possible de créer une classe Event qui représente un événement de l’interface API de Google. La cohésion de la classe ReservationManager ne serait pas significativement améliorée, puisqu’elle conserverait toujours la responsabilité de fournir les paramètres de l’événement. L’ajout de la classe Event permettrait de valider l’utilisation des bonnes propriétés et des bons types lors de la compilation du code. Toutefois, puisque les événements de l’interface API de Google sont complexes, l’ajout de la classe Event demanderait beaucoup de temps de développement et de tests. La pertinence de la classe Event dépend du contexte de développement dans lequel vous vous trouvez.\nclass ReservationManager {\n    public addReservation(String memberId, String bookId, String bookCopyId, Date expiration) {\n        var member = members.get(memberId);\n        var book = books.get(bookId);\n        \n        // We assume that we create the reservation for the member some way...\n\n        // Then we add an event to the Google Calendar of the member to remind them to return their book\n        var dateAsString = expiration.toLocaleDateString(\"fr-CA\", {year: \"numeric\", month: \"2-digit\", day: \"2-digit\"});\n\n        GoogleCalendar.addEvent({\n            \"summary\": `Your reservation for ${book.getTitle()} is expired`,\n            \"location\": \"475 Boul. de Maisonneuve E, Montréal, QC H2L 5C4\",\n            \"description\": \"You must return your book today to avoid late fees.\",\n            \"start\": {\n                \"date\": dateAsString,\n                \"timeZone\": \"America/Toronto\"\n            },\n            \"end\": {\n                \"date\": dateAsString,\n                \"timeZone\": \"America/Toronto\"\n            },\n            \"reminders\": {\n                \"useDefault\": false,\n                \"overrides\": [\n                    // Send a reminder the day before by email and push notification\n                    {\"method\": \"email\", \"minutes\": 24 * 60},\n                    {\"method\": \"popup\", \"minutes\": 24 * 60}\n                ]\n            }\n        }, member.email, member.googlePrivateKey);\n    }\n}\n\nclass GoogleCalendar {\n\n    /*\n     * References\n     * https://developers.google.com/calendar/api/v3/reference?hl=fr\n     * https://dev.to/pedrohase/create-google-calender-events-using-the-google-api-and-service-accounts-in-nodejs-22m8\n     */\n    public static addEvent(event, email, privateKey) {\n        // Create a client that we can use to communicate with Google \n        const client = new JWT({\n            email: email,\n            key: privateKey,\n            scopes: [\n                \"https://www.googleapis.com/auth/calendar\",\n                \"https://www.googleapis.com/auth/calendar.events\",\n            ],\n        });\n\n        const calendar = google.calendar({ version: \"v3\" });\n\n        // We make a request to Google Calendar API.\n        const res = await calendar.events.insert({\n            calendarId: \"primary\",\n            auth: client,\n            requestBody: event,\n        });\n    }\n}\n\n\n\n\n\n\n\n\nFord, N. (2009, 24 février). Evolutionary architecture and emergent design: Investigating architecture and design. [{CT}316]. Repéré à https://web.archive.org/web/20161029141308/http://www.ibm.com/developerworks/library/j-eaed1/\n\n\nFowler, M. (2018). Refactoring: Improving the Design of Existing Code (2ᵉ éd.). Boston : Addison-Wesley Professional.\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "DetteTechnique.html#origine",
    "href": "DetteTechnique.html#origine",
    "title": "7  Dette technique",
    "section": "7.1 Origine",
    "text": "7.1 Origine\nLa dette technique est une forme de risque qui peut apporter des bénéfices ou des pertes. Tout dépend de la quantité d’intérêt à payer. L’inventeur du wiki, Ward Cunningham, a utilisé la métaphore de la dette dans un projet de développement de logiciel de gestion de portefeuille réalisé dans une variante du langage Smalltalk (1992) :\n\n\n\n\n\n\nUn autre piège plus sérieux est l’échec à consolider [un design]. Bien que le code non raffiné puisse fonctionner correctement et être totalement acceptable pour le client ou la cliente, des quantités excessives de ce genre de code rendront le programme impossible à maîtriser, ce qui entraînera une surspécialisation des programmeurs et programmeuses et, finalement, un produit inflexible. Livrer du code non raffiné équivaut à s’endetter. Une petite dette accélère le développement tant qu’elle est remboursée rapidement avec une réécriture. [Le paradigme des] objets rend le coût de cette transaction tolérable. Le danger survient lorsque la dette n’est pas remboursée. Chaque minute passée sur un code qui n’est pas tout à fait correct compte comme un intérêt sur cette dette. Des organisations entières peuvent être bloquées par l’endettement d’une implémentation non consolidée, orientée objet ou autre.\n\n\n\nComme c’est une métaphore puissante, beaucoup de développeurs et développeuses l’utilisent, et c’est un terme avec une certaine popularité. Dans une vidéo  plus récente, Cunningham a rappelé que l’origine de la métaphore s’inspire du code qui est incohérent par rapport à un problème complexe plutôt que du code simplement « mal écrit » :\n\n\n\n\n\n\nL’explication que j’ai donnée à mon patron, et c’était un logiciel financier, était une analogie financière que j’ai appelée « la métaphore de la dette ». Et cela veut dire que si nous ne parvenions pas à aligner notre programme sur ce que nous considérions alors comme la bonne façon de penser à nos objets financiers, alors nous allions continuellement trébucher sur ce désaccord, et cela nous ralentirait, comme payer des intérêts sur un prêt.\n \n[…]\n \nBeaucoup de gens (au moins des blogueurs et blogueuses) ont expliqué la métaphore de la dette et l’ont confondue, je pense, avec l’idée que vous pourriez écrire mal le code avec l’intention de faire du bon travail plus tard et de penser que c’était la principale source de dette. Je ne suis jamais favorable à l’écriture médiocre du code, mais je suis en faveur de l’écriture de code pour refléter votre compréhension actuelle d’un problème, même si cette compréhension est partielle."
  },
  {
    "objectID": "DetteTechnique.html#nuances-de-la-dette-technique",
    "href": "DetteTechnique.html#nuances-de-la-dette-technique",
    "title": "7  Dette technique",
    "section": "7.2 Nuances de la dette technique",
    "text": "7.2 Nuances de la dette technique\nFowler a également abordé le sujet de la dette, notamment à propos de la distinction entre du code « mal écrit » et les compromis de conception faits avec une intention d’accélérer le développement :\n\n\n\n\n\n\nJe pense que la métaphore de la dette fonctionne bien dans les deux cas – la différence est dans la nature de la dette. Le code mal écrit est une dette imprudente qui se traduit par des paiements d’intérêt paralysants ou par une longue période de remboursement du capital. Il y a quelques projets où nous avons pris en charge une base de code avec une dette élevée et nous avons trouvé la métaphore très utile pour discuter avec l’administration de notre client de comment l’aborder.\n \nLa métaphore de la dette nous rappelle les choix que nous pouvons faire avec les anomalies de conception. La dette prudente qui a permis de compléter une version du logiciel ne vaut peut-être pas la peine d’être remboursée si les paiements d’intérêt sont suffisamment faibles, par exemple si les anomalies sont dans une partie rarement touchée de la base de code.\n\nLa distinction utile n’est donc pas entre dette et non-dette, mais entre dette prudente et dette imprudente.\n \n[…] Il y a aussi une différence entre la dette délibérée et dette involontaire. L’exemple de la dette prudente est délibéré parce que l’équipe sait qu’elle s’endette et réfléchit donc à la question de savoir si le bénéfice de livrer plus tôt une version du logiciel est supérieur au coût de son remboursement. Une équipe ignorante des pratiques de conception prend sa dette imprudente sans même constater à quel point elle s’endette.\n \nLa dette imprudente pourrait aussi être délibérée. Une équipe peut connaître les bonnes pratiques de conception, voire être capable de les mettre en pratique, mais décide finalement d’aller « à la va-vite » parce qu’elle pense qu’elle ne peut pas se permettre le temps nécessaire pour écrire du code propre.\n\n\n\nLa dette peut être classifiée dans un quadrant comme sur le tableau 7.1. Selon Fowler, la dette mentionnée par Ward Cunningham dans sa vidéo peut être classifiée comme « prudente et involontaire ». Selon son expérience, Fowler remarque que la dette « imprudente et délibérée » est rarement rentable.\n\n\nTableau 7.1: Classification de la dette selon Fowler (2009)\n\n\n\n\n\n\n\nDette\nImprudente\nPrudente\n\n\n\n\nDélibérée\n« On n’a pas le temps pour la conception ! » Cette forme de dette est rarement rentable.\n« Il faut livrer maintenant puis en assumer les conséquences. » Exemple  : La dette est due à une partie limitée du code.\n\n\nInvolontaire\n« C’est quoi, la séparation en couches ? » Il s’agit de l’ignorance des bonnes pratiques.\n« Maintenant, on sait comment on aurait dû le faire. » C’est tenter une solution malgré une compréhension limitée du problème."
  },
  {
    "objectID": "DetteTechnique.html#résumé",
    "href": "DetteTechnique.html#résumé",
    "title": "7  Dette technique",
    "section": "7.3 Résumé",
    "text": "7.3 Résumé\n\nIl n’est pas toujours possible de faire une conception facile à utiliser et à modifier (sans dette technique), puisque certaines choses sont impossibles à prévoir, surtout dans une application avec beaucoup de complexité.\nIgnorer complètement le design en faisant du « hacking cowboy » peut apporter un avantage à court terme pour valider des hypothèses rapidement, par exemple dans un contexte d’entreprise en démarrage sans beaucoup de financement ou dans un concours de programmation. Cependant, le code produit dans ce genre de contexte aura des problèmes importants (la dette technique) à long terme.\nLa dette technique peut aussi être due à l’incompétence (l’ignorance des bonnes pratiques comme la séparation des couches dans une architecture logique, comme l’exemple d’une couche présentation et d’une couche domaine sur la figure 5.7).\n\n\n\n\n\nAvgeriou, P., Kruchten, P., Ozkaya, I., et Seaman, C. (2016). Managing Technical Debt in Software Engineering (Dagstuhl Seminar 16162). Dagstuhl Reports, 6(4), 110‑138. https://doi.org/10.4230/DagRep.6.4.110\n\n\nCunningham, W. (1992). The WyCash portfolio management system. Dans Conference on Object-Oriented Programming Systems, Languages, and Applications.\n\n\nFowler, M. (2007, juin). Bliki: DesignStaminaHypothesis. martinfowler.com. Repéré à https://www.martinfowler.com/bliki/DesignStaminaHypothesis.html\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "Contrats.html#les-contrats-en-bref",
    "href": "Contrats.html#les-contrats-en-bref",
    "title": "8  Contrats d’opération",
    "section": "8.1 Les contrats en bref",
    "text": "8.1 Les contrats en bref\nLes contrats d’opération sont le sujet du chapitre 11  (2005). Voici les points importants pour la méthodologie enseignée dans le présent manuel :\n\nUn contrat d’opération correspond à une opération système provenant d’un DSS.\nOn fait des contrats surtout pour les opérations système ayant une certaine complexité.\nUne postcondition décrit les modifications de l’état des objets dans le modèle du domaine après une opération système.\nLe vocabulaire pour les postconditions provient du modèle du domaine. Il s’agit des noms de classes, d’attributs et d’associations qu’on trouve dans le MDD.\nChaque postcondition doit avoir la bonne forme :\n\ncréation (ou suppression) d’instances ;\nmodification des valeurs des attributs ;\nformation (ou rupture) d’associations.\n\nOn ne spécifie pas les préconditions dans les contrats (Larman ne donne pas beaucoup de directives claires à ce propos).\nIl ne faut pas confondre les postconditions d’un contrat d’opération et les postconditions d’un cas d’utilisation. Ce sont deux choses différentes.\nQuand on rédige les contrats, il est normal de découvrir dans le modèle du domaine des incohérences ou des éléments manquants. Il faut les corriger (il faut donc changer le MDD), car cela fait partie d’un processus itératif et évolutif."
  },
  {
    "objectID": "Contrats.html#sec-contrat_exemple",
    "href": "Contrats.html#sec-contrat_exemple",
    "title": "8  Contrats d’opération",
    "section": "8.2 Exemple : Contrats d’opération pour Attaquer un pays",
    "text": "8.2 Exemple : Contrats d’opération pour Attaquer un pays\nVoir la figure 8.2 pour les changements dans les objets du modèle du domaine correspondant aux postconditions.\n\nAttaquer un pays\n\nOpération : démarrerAttaque(paysAttaquant:String, paysDéfenseur:String)\n\n\nPostconditions :\n\nUne nouvelle instance a de Attaque a été créée.\na a été associée au Pays correspondant à paysAttaquant.\na a été associée au Pays correspondant à paysDéfenseur.\n\n\n\nOpération : annoncerAttaque(nbRégimentsAttaquant:int)\n\n\nPostcondition :\n\na.nbAttaquant est devenu nbRégimentsAttaquant.\n\n\n\nOpération : annoncerDéfense(nbRégimentsDéfendant:int)\n\n\nPostconditions :\n\na.nbDéfenseur est devenu nbRégimentsDéfendant.\nL’attribut valeur des d1 à d5 est devenu un nombre entier aléatoire entre 1 et 6.\nOccupation.nbRégiments est ajusté selon le résultat des valeurs correspondant à paysAttaquant.\nOccupation.nbRégiments est ajusté selon le résultat des valeurs correspondant à paysDéfenseur.\n\n\n\n\n\n\n\nImportant\n\n\n\nLes règles pour la résolution d’une attaque dans le jeu Risk sont complexes. Pour faire un exemple plus facile à comprendre, on en fait abstraction.\n\n\n\n\n\n\nFigure 8.2: Les postconditions décrivent la manipulation d’objets dans un MDD (la partie inférieure ici est un diagramme d’objets)."
  },
  {
    "objectID": "Contrats.html#feuille-de-référence",
    "href": "Contrats.html#feuille-de-référence",
    "title": "8  Contrats d’opération",
    "section": "8.3 Feuille de référence",
    "text": "8.3 Feuille de référence\nPour faire des contrats, voici une démarche générale :\n\nFaire un contrat pour chaque opération système.\nPorter une attention à sa signature (les arguments et leur type).\nRappeler les formes de postconditions :\n\ncréer/supprimer instances ;\nformer/briser associations ;\nmodifier attributs.\n\nUtiliser le vocabulaire du modèle du domaine dans les postconditions. Ça veut dire qu’il faut parler d’instances de classes conceptuelles, de leurs attributs et des associations entre ces classes.\nNe pas créer une instance de classe qui existe déjà, par exemple un produit (connu) dans un magasin, un acteur (connu) qui se connecte au système, ou, dans l’exemple de Risk, un Pays (voir la partie inférieure de la figure 8.2).\nNe rien oublier. Marquer le MDD ou dessiner un diagramme d’objets, comme à la partie inférieure de la figure 8.2 si nécessaire."
  },
  {
    "objectID": "Contrats.html#exercices",
    "href": "Contrats.html#exercices",
    "title": "8  Contrats d’opération",
    "section": "8.4 Exercices",
    "text": "8.4 Exercices\n\nExercice 8.1 (terminerAttaque()) Rédigez le contrat d’opération pour terminerAttaque(). Il faut considérer les règles d’attaque (voir la page de wikiHow) et les cas où une attaque a réussi, c’est-à-dire que le paysDéfenseur change de Joueur (celui du paysAttaquant). Suivez les exemples de contrats d’opération présentés à la Section 8.2.\n\n\nExercice 8.2 (Contrats d’opération pour Traiter une vente) Rédigez un contrat d’opération pour chacune des opérations système dans le DSS (et qui doit être cohérent avec le MDD) de la Section B.1. Suivez les exemples de contrats d’opération à la Section 8.2.\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "RDCU.html#spécifier-le-contrôleur",
    "href": "RDCU.html#spécifier-le-contrôleur",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.1 Spécifier le contrôleur",
    "text": "9.1 Spécifier le contrôleur\nPour commencer une RDCU, on spécifie le contrôleur selon GRASP. Dans les travaux réalisés selon la méthodologie de ce manuel, vous devez indiquer pourquoi vous avez choisi telle classe pour être le contrôleur. Ce n’est pas un choix arbitraire. Référez-vous à la définition dans le tableau 6.1.\nPour initialiser les liens entre la couche présentation et les contrôleurs GRASP, Larman vous propose de le faire dans la RDCU pour l’initialisation, le scénario Démarrer."
  },
  {
    "objectID": "RDCU.html#satisfaire-les-postconditions",
    "href": "RDCU.html#satisfaire-les-postconditions",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.2 Satisfaire les postconditions",
    "text": "9.2 Satisfaire les postconditions\n\n9.2.1 Créer une instance\nCertaines postconditions concernent la création d’une instance. Dans votre RDCU, vous devez respecter le GRASP Créateur, selon la définition dans le tableau 6.1.\n\n\n\n\n\n\nMise en garde\n\n\n\nUne erreur potentielle est de donner la responsabilité de créer à un contrôleur, puisqu’il a les données pour initialiser l’objet. Bien que ce soit justifiable par le principe GRASP Créateur, il vaut mieux favoriser une classe qui agrège l’objet à créer, si nécessaire.\n\n\n\n\n9.2.2 Former une association\nPour les postconditions où il faut former une association entre un objet a et un objet b, il y a plusieurs façons de faire.\n\nS’il y a une agrégation entre les objets, il s’agit probablement d’une méthode add() sur l’objet qui agrège.\nS’il y a une association simple, il faut considérer la navigabilité de l’association. Est-ce qu’il faut pouvoir retrouver l’objet a à partir de l’objet b, ou vice-versa ? Il s’agira d’une méthode setB(b) sur l’objet a (pour trouver b à partir de a), etc.\nS’il faut former une association entre un objet et un autre « sur une base de correspondance avec » ou « correspondant à » un identifiant passé comme argument (voir les postconditions de l’exemple à la section Section 8.2), alors il faut repérer le bon objet d’abord. Voir la section Transformer identifiants en objets.\n\nDans la plupart des cas, la justification pour former une association est GRASP Expert, défini dans le tableau 6.1. Il faut faire attention à la visibilité .\n\n\n9.2.3 Modifier un attribut\nPour les postconditions où il faut modifier un attribut, c’est assez évident. Il suffit de suivre le principe GRASP Expert, défini dans le tableau 6.1. Très souvent, c’est une méthode setX(valeur), où X correspond à l’attribut qui sera modifié à valeur. Attention à la visibilité .\nLorsque l’attribut d’un objet doit être modifié juste après la création de ce dernier, ça peut se faire dans le constructeur, comme illustré sur la figure 9.2.\n\n\n:Plateauloopcreate(nom):Case\nFigure 9.2: Combiner la création d’une instance et une modification de son attribut dans un constructeur."
  },
  {
    "objectID": "RDCU.html#sec-Visibilite",
    "href": "RDCU.html#sec-Visibilite",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.3 Visibilité",
    "text": "9.3 Visibilité\nDans une approche orientée objet, puisqu’on doit éviter trop de couplage, un objet ne voit pas tous les autres objets. Si un objet a veut envoyer un message à un objet b, ce dernier doit lui être visible. Ça veut dire que a doit connaître une référence vers b.\n\n\n\n\n\n\nAvertissement\n\n\n\nDans un diagramme de séquence pour une RDCU, il est facile de montrer des objets a et b et de dessiner une flèche entre l’objet a et b puis d’écrire le nom d’une méthode pour représenter l’appel. Cependant, dans un programme codé en TypeScript ou en Java, il y aura des erreurs de compilation si a n’a pas une référence pour b. L’approche de Larman propose d’être sensible à la visibilité lors de la conception (en faisant les RDCU), car ajouter une visibilité implique l’augmentation du couplage.\n\n\nRégler les problèmes de visibilité lorsqu’on crée une RDCU nécessite de la créativité. Il faut pratiquer pour apprendre la démarche, mais les points suivants peuvent aider :\n\nPour un objet racine (par exemple Université), il peut s’agir d’un objet Singleton, qui aura une visibilité globale, c’est-à-dire que n’importe quel objet pourrait lui envoyer un message. Cependant, les objets Singleton posent des problèmes de conception, notamment pour les tests. Il vaut mieux éviter ce choix, si possible.\nVoir cette réponse sur Stack Overflow .\nSinon, il faudra que l’objet émetteur (a) ait une référence de l’objet récepteur (b). Par exemple, sur la figure 9.3, la référence à b peut être :\n\nstockée comme un attribut de a,\npassée comme un argument dans un message antérieur, ou\naffectée dans une variable locale de la méthode où unMessage() sera envoyé.\n\n\nPour plus de détails, voir le chapitre sur la Visibilité (F18/A19) .\n\n\na:Ab:B...unMessage()...\nFigure 9.3: L’objet b doit être visible à l’objet a si a veut lui envoyer un message.\n\n\nPour initialiser les références nécessaires pour la bonne visibilité, Larman vous propose de faire ça dans la RDCU pour l’initialisation, le scénario Démarrer."
  },
  {
    "objectID": "RDCU.html#sec-TransformerIDenObjets",
    "href": "RDCU.html#sec-TransformerIDenObjets",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.4 Transformer les identifiants en objets",
    "text": "9.4 Transformer les identifiants en objets\nLa directive d’utiliser les types primitifs pour les arguments dans les opérations système (voir la Chapitre 5) nous mène à un problème récurrent dans les RDCU : transformer un identifiant (un argument de type String ou int) en objet représenté par cet identifiant. Larman vous propose un idiome (pas vraiment un pattern) nommé Transformer identifiant en objet (fin de la section F23.8, p.451/A26.8, IDs to Objects ), qui sert à repérer l’objet qui correspond à l’identifiant.\nIl y a un exemple à la figure 9.4 provenant du chapitre sur l’Application des patterns GoF (figure F23.18 ). Un autre exemple du livre de Larman (2005) est l’identifiant codeArticle transformé en objet DescriptionProduit par la méthode\nCatalogueProduits.getDescProduit(codeArticle:String):DescriptionProduit.\n\n\n:Registre:Magasinv:VentesaisirClientPourRemise(idClient)c = getClient(idClient)Selon Expert etles ID en objetssaisirClientPourRemise(c:Client)\nFigure 9.4: Un identifiant idClient:String est transformé en objet c:Client, qui est ensuite envoyé à la Vente en cours.\n\n\nLa Section 9.5 explique comment implémenter la transformation avec un tableau associatif."
  },
  {
    "objectID": "RDCU.html#sec-UtilisationMap",
    "href": "RDCU.html#sec-UtilisationMap",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.5 Utilisation d’un tableau associatif (Map<clé, objet>)",
    "text": "9.5 Utilisation d’un tableau associatif (Map<clé, objet>)\nPour transformer un identifiant en objet, il est pratique d’utiliser un tableau associatif (aussi appelé dictionnaire ou map en anglais) . L’exemple du livre de Larman (2005) concerne le problème de repérer une Case Monopoly à partir de son nom (String). C’est illustré sur la figure F16.7/A17.7 .\nNotez que les exemples de Larman (2005) ne montrent qu’un seul type dans le tableau associatif, par exemple Map<Case>, tandis que, normalement, il faut spécifier aussi le type de la clé, par exemple Map<String, Case>.\nUn tableau associatif fournit une méthode get ou find pour rechercher un objet à partir de sa clé (son identifiant). La figure 9.5 en est un exemple.\n\n\n:PlateaucMap:Map<String, Case>s = getCase(nom)Plateau agrège toutes lesCases et possède un Mapavec nom comme clé.c = get(nom) : Case\nFigure 9.5: Exemple de l’utilisation d’un tableau associatif pour trouver une Case Monopoly à partir de son nom.\n\n\nDans la section suivante, l’initialisation des éléments utilisés dans les RDCU (comme des tableaux associatifs) est expliquée."
  },
  {
    "objectID": "RDCU.html#sec-rdcu_Demarrer",
    "href": "RDCU.html#sec-rdcu_Demarrer",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.6 RDCU pour l’initialisation, le scénario Démarrer",
    "text": "9.6 RDCU pour l’initialisation, le scénario Démarrer\nLe lancement de l’application correspond à la RDCU « Démarrer ». La section Initialisation et cas d’utilisation Démarrer (F17.4 , p. 345) ou Initialization and the Start Up Use Case (A18.4 , p.274) traite ce sujet important. C’est dans cette conception où il faut mettre en place tous les éléments importants pour les hypothèses faites dans les autres RDCU, par exemple les classes de collection (map), les références pour la visibilité, l’initialisation des contrôleurs, etc.\nVoici quelques points importants :\n\nLe lancement d’une application dépend du langage de programmation et du système d’exploitation.\nÀ chaque nouvelle RDCU, on doit possiblement actualiser la RDCU « Démarrer » pour tenir compte des hypothèses faites dans la dernière RDCU. Elle est assez « instable » pour cette raison. Larman recommande de faire sa conception en dernier lieu.\nIl faut choisir l’objet du domaine initial, qui est souvent l’objet racine, mais ça dépend du domaine. Cet objet aura la responsabilité, lors de sa création, de générer ses « enfants » directs, puis chaque « enfant » aura à faire la même chose selon la structure. Par exemple, selon le MDD pour le jeu Risk à la figure 4.2, JeuRisk pourrait être l’objet racine, qui devra créer l’objet PlateauRisk et les cinq instances de Dé. L’objet PlateauRisk, lors de son initialisation, pourra instancier les 42 objets Pays et les six objets Continent, en passant à chaque Continent ses objets Pays lors de son initialisation. Si PlateauRisk fournit une méthode getPays(nom) qui dépend d’un tableau associatif selon Transformer les identifiants en objets, alors c’est dans l’initialisation de cette classe que l’instance de Map<String,Pays> sera créée.\nSelon l’application, les objets peuvent être chargés en mémoire à partir d’un système de persistance, par exemple une base de données ou un fichier. Pour l’exemple de Risk, PlateauRisk pourrait charger, à partir d’un fichier JSON, des données pour initialiser toutes les instances de Pays. Pour une application d’inscription de cours à l’université, il se peut que toutes les descriptions de cours soient chargées en mémoire à partir d’une base de données. Une base de données amène un lot d’avantages et d’inconvénients, et elle n’est pas toujours nécessaire. Dans la méthodologie de ce manuel, on n’aborde pas le problème des bases de données (c’est le sujet d’un autre cours).\n\n\n\n:ObjetMaincreate:JeuRiskJeuRisk est l'objet racine.Contrôleurne s'applique pas ici, car il ne s'agit pas d'une opération systèmeloop[i<5]dés[i] = create:DéparCréateurJeuRisk agrège Décreate:PlateauRiskparCréateurJeuRisk agrège PlateauRiskpMap = createpMap:Map<String,Pays>parCréateur: PlateauRisk agrège Map<String, Pays>continentsAvecPays[] =chargerContinentsAvecPaysParExpertCharger les données d'un fichier JSONloop[i<continentsAvecPays.size]create(continentsAvecPays[i].nom, ...):ContinentparCréateur: PlateauRisk agrège Continentloop[j<continentsAvecPays[i].pays.size]p = create(continentsAvecPays[i].pays[j].nom, ...)p:PaysparCréateur: PlateauRisk agrège Paysadd(p)ParExpertadd(p)ParExpert\nFigure 9.6: Exemple de l’initialisation partielle du jeu Risk, avec les principes GRASP et les tableaux associatifs pour faciliter la transformation d’identifiants en objets."
  },
  {
    "objectID": "RDCU.html#réduire-le-décalage-des-représentations",
    "href": "RDCU.html#réduire-le-décalage-des-représentations",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.7 Réduire le décalage des représentations",
    "text": "9.7 Réduire le décalage des représentations\nLe principe du Décalage des représentations est la différence entre la modélisation (la représentation) du problème (du domaine) et la modélisation de la solution. Lorsqu’on fait l’ébauche d’une RDCU, on peut réduire le décalage des représentations principalement en s’inspirant des classes conceptuelles (du modèle du domaine) pour proposer des classes logicielles dans la solution décrite dans la RDCU. Plus une solution ressemble à la description du problème, plus elle sera facile à comprendre.\n\n\n\n\n\n\nMise en garde\n\n\n\nUne application de patterns GoF à la solution peut nuire à ce principe, car ces patterns ajoutent souvent des classes logicielles n’ayant aucun lien avec le modèle du domaine. Par exemple, un Visiteur ou un Itérateur sont des classes logicielles sans binôme dans le modèle du domaine. Il faut vérifier avec une personne expérimentée (l’architecte du projet si possible) que l’application du pattern est justifiée, qu’elle apporte de vrais bénéfices au design en dépit des désavantages dus à des classes ajoutées. Chaque fois qu’on propose des classes logicielles qui n’ont pas de liens avec la représentation du problème du domaine, on augmente le décalage des représentations et l’on rend la solution un peu plus difficile à comprendre. C’est aussi une forme de Complexité circonstancielle (provenant des choix de conception). Ce dilemme est un bon exemple de la nature pernicieuse de la conception de logiciels. Il est très difficile, même pour les spécialistes en conception, de trouver un bon équilibre entre toutes les forces : la maintenabilité, la simplicité, les fonctionnalités, etc. Vous pouvez en lire plus dans cette réponse sur Stack Overflow ."
  },
  {
    "objectID": "RDCU.html#sec-FaireSoiMeme",
    "href": "RDCU.html#sec-FaireSoiMeme",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.8 Pattern « Faire soi-même »",
    "text": "9.8 Pattern « Faire soi-même »\nDans la section F30.8/A33.7 , Larman mentionne le pattern « Faire soi-même » de Peter Coad (1997), qui permet de réduire le Décalage des représentations, même s’il ne représente pas exactement la réalité des objets (voir la figure 9.7 (a)) :\n\n\n\n\n\n\n\n(a) Dés dans la vraie vie (« Hand of chance » (CC BY 2.0) par Alexandra E Rust).\n\n\n\n\n\n\nDéface : intbrasser()\n(b) Dé dans un logiciel selon Faire soi-même.\n\n\n\n\nFigure 9.7: Faire soi-même : « Moi, objet logiciel, je fais moi-même ce qu’on fait normalement à l’objet réel dont je suis une abstraction » de Coad (1997)."
  },
  {
    "objectID": "RDCU.html#exercices",
    "href": "RDCU.html#exercices",
    "title": "9  Réalisations de cas d’utilisation (RDCU)",
    "section": "9.9 Exercices",
    "text": "9.9 Exercices\n\nExercice 9.1 (Coder des méthodes à partir des diagrammes de séquence) Pour chacun des diagrammes suivants, écrivez les classes TypeScript avec les méthodes indiquées dans le diagramme\n(cet exercice complémente le livre de Larman, 2005 à la section F18.6/A20.4 ) .\n\n\n\n\n\n\nAstuce\n\n\n\nVous pouvez utiliser VS Code pour vous aider avec le TypeScript, mais cet outil ne sera pas forcément permis lors d’un examen.\n\n\n\n\n:A:Bexecute(3)result = setItem(\"Fred\")\nFigure 9.8: Exemple de diagramme de séquence.\n\n\nVoici un modèle à suivre. Pour le diagramme sur la figure 9.8, on code les classes suivantes en TypeScript :\nclass A {\n    b: B;  // A envoie un message à B, visibilité d'attribut\n    execute(arg0:number):any {\n        const result = this.b.setItem(\"Fred\");\n    }\n}\n\nclass B {\n    setItem(arg0:string):any {\n        //...\n    }\n}\n\nÉcrivez le code pour la figure suivante.\n:Bernard:Aliceinitallô(12)create:Autre\"oui\"15\nÉcrivez le code pour la création de la collection de Vente (Larman, 2005), figure F17.6/A18.6 ].\nÉcrivez le code pour l’utilisation d’un Cornet (à dés, gobelet dans lequel on agite les dés) dans le jeu Monopoly (Larman, 2005), figure F22.9/A25.9 ].\nÉcrivez le code pour les appels polymorphes de la méthode atterrirSur dans le jeu Monopoly (Larman, 2005), figures F22.6/A25.6 et F22.7/A25.7 ].\n\n\n\nExercice 9.2 (RDCU pour le cas d’utilisation Ouvrir la caisse) Faites les RDCU pour le cas d’utilisation Ouvrir la caisse. Vous y trouverez également des artefacts tels que le DSS, les contrats d’opération et le modèle du domaine. Ils sont essentiels pour faire les RDCU selon la méthodologie présentée dans ce manuel.\n\n\nExercice 9.3 (Critique d’une conception) Dans cet exercice, l’objectif est de vous sensibiliser à la facilité de comprendre une conception à partir d’un problème. Un objectif secondaire est de considérer les choix de conception sur le plan de la cohésion et du couplage. Ici, il s’agit du jeu Monopoly, qui est un exemple proposé par Larman (2005), pour lequel il a également proposé un modèle du domaine et une conception, selon la méthodologie.\nPour cet exercice, nous examinerons une conception orientée objet réelle du jeu Monopoly disponible sur GitHub, soit Emojiopoly. Voici le travail à faire.\n\nConsidérez les deux artefacts :\n\nun modèle du domaine de Monopoly proposé par Larman (2005) (il y a une version en français et une autre en anglais, puisque le code TypeScript est en anglais) ;\nun modèle d’une solution sous forme de diagramme de classes logicielles, créé à partir du code TypeScript dans le dépôt mentionné ci-dessus).\n\nNous faisons une hypothèse que l’équipe qui a développé Emojiopoly n’a pas commencé avec le MDD de Larman.\nComparez ces deux artefacts et faites des remarques sur la conception, surtout par rapport au MDD et au décalage des représentations.\nFaites des remarques sur la solution concernant la cohésion et le couplage.\n\n\nDiagramme de classes d’Emojiopoly\nPour visualiser la conception, nous avons généré un diagramme de classes en UML sur la figure 9.9 avec l’outil tplant.\n\n\nCardtext: stringaction: \"advance\" | \"back\" | \"choice\" | \"payeach\" | \"collecteach\" |\"doubletransport\" | \"earn\" | \"pay\" | \"stealmoney\" | \"stolenmoney\" |\"streetrepairs\" | \"gotojail\"value?: string | number | number[]MonopolyGamejackpot: numbercurrentTurnIndex: numberconsecutiveDoubles: numberplayers: Player[]currentPlayer: Playerdice: number[]isTurnFinished: booleanunpaidDebts: Debt[]chanceCards: Card[]chestCards: Card[]chanceCardIndex: numberchestCardIndex: numberboard: Square[]playerNames: string[]houseRules: HouseRulesmessageEventHandler: (message: string) => voidaddToJackpot(amount: number): voidrollDice(die1?: number, die2?: number): voidmoveToSquare(newSquare: Square, awardSalary?: boolean): voidsendToJail(): voidmoveBack(numberOfSpaces: number): voidpostBail(): voidtakeChance(): voidtakeChest(): voidhandleCard(card: Card): voidmovePlayer(): voidpayDebts(): voidfinishTurn(): voidHouseRulesPlayerownedProperties: Property[]currentSquare: SquareturnsInJail: numbername: stringmoney: numberPropertybuildingsCount: numberisMortgaged: booleanowner: Playername: stringcolor: \"brown\" | \"lightblue\" | \"pink\" | \"orange\" | \"red\" | \"yellow\" |\"green\" | \"blue\" | \"white\"price: numberrent: number[] | \"transport\" | \"utility\"buildPrice: numberSquareoccupants: Player[]squareContents: \"gotojail\" | Property | \"go\" | \"jail\" | \"parking\" |\"chance\" | \"chest\" | \"incometax\" | \"supertax\"addOccupant(occupant: Player): voidremoveOccupant(occupant: Player): voidDebtamount: numbergame: MonopolyGamedebtor: Playercreditor: PlayerinitialAmount: numberpayDebt(): voidtoString(): string**1**1*11*11\nFigure 9.9: Diagramme de classes logicielles (TypeScript) pour le projet Emojiopoly.\n\n\n\n\nModèle du domaine de Monopoly\nPuisque la solution d’Emojiopoly est en anglais, vous pouvez regarder le modèle du domaine de Monopoly en français (figure F26.35 ) et en anglais (figure A31.35 ) pour vous aider à comprendre les termes.\n\n\n\n\n\n\nCoad, P. (1997). Object Models: Strategies, Patterns, and Applications (2ᵉ éd.). Upper Saddle River, N.J : Pearson Technology Group.\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "TDD.html#kata-tdd",
    "href": "TDD.html#kata-tdd",
    "title": "10  Développement piloté par les tests",
    "section": "10.1 Kata TDD",
    "text": "10.1 Kata TDD\nPour apprendre à faire du développement piloté par les tests (et pour apprendre les cadriciels supportant l’automatisation des tests), il existe une activité nommée « kata TDD ». Kata est un terme japonais désignant une séquence de techniques réalisée dans le vide dans les arts martiaux japonais. En voici une vidéo . C’est un outil de transmission de techniques et de principes de combat.\n\n\n\nFigure 10.2: Étudiante de karaté faisant le kata Bassai Dai (photo « Karate » (CC BY-SA 2.0) par The Consortium).\n\n\nAlors, le « kata TDD » a été proposé par Dave Thomas, et le but est de développer la fluidité avec le développement piloté par les tests. Un kata TDD se pratique avec un IDE (environnement de développement logiciel) et un support pour les tests (par exemple JUnit). Pratiquer le même kata peut améliorer votre habileté de programmation. On peut pratiquer le même kata dans un langage différent, avec un IDE différent ou avec un environnement de test différent. Le kata vous permet d’avoir une facilité avec les aspects techniques de développement dans plusieurs dimensions (complétion de code pour le test et pour l’application, interface API du cadriciel de test, etc.).\nEn plus, les activités de réusinage sont normalement intégrées dans un kata. Le fait de travailler en petits pas peut faire en sorte que la dette technique s’accumule. Les IDE facilitent l’application des activités de réusinage. Un langage fortement typé comme Java permet d’avoir plus de fonctionnalités automatisées de réusinage dans un IDE qu’un langage dynamique comme JavaScript ou Python. Une activité de base de réusinage est le renommage d’une variable ou d’une fonction. Le réusinage rend le code plus facile à comprendre et à maintenir.\n\n10.1.1 Exemple de kata TDD FizzBuzz\nL’inspiration de cet exercice vient de codingdojo.org.\nDans cet exercice, il faut écrire selon le développement piloté par les tests un programme qui imprime les nombres de 1 à 100. Mais, pour les multiples de trois, il faut imprimer Fizz au lieu du nombre et, pour les multiples de cinq, il faut imprimer Buzz. Pour les nombres étant des multiples de trois et de cinq, il faut imprimer FizzBuzz. Voici un exemple des sorties :\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n... etc. jusqu'à 100\n\n10.1.1.1 Préalables\nIl faut installer un IDE qui supporte les activités de réusinage (refactorings) comme Visual Studio Code, Eclipse, IntelliJ, etc., puis un cadriciel de test (JUnit, Mocha/Chai, Jest, unittest, etc.). Pour un exemple qui fonctionne en TypeScript, vous pouvez cloner le code à partir de ce dépôt.\n\n\n10.1.1.2 Déroulement\nCet exercice peut se faire individuellement ou en équipe de deux. En équipe, une personne écrit le test, et l’autre écrit le code pour passer le test (c’est la variante ping-pong). Chaque personne réfléchit aux activités de réusinage éventuelles lorsque le projet est dans l’état vert (figure 10.1). Les membres de l’équipe peuvent changer de rôle (testeur ou testeuse, codeur ou codeuse) après un certain nombre d’étapes, ou après avoir terminé le kata entier.\nPour respecter la philosophie de petits pas, il vaut mieux :\n\nne lire que l’étape courante ;\nne travailler que sur l’étape courante ;\nne faire que les tests avec les entrées valides.\n\n\n\n10.1.1.3 Kata pour FizzBuzz\nLes étapes sont simples et précises. Il s’agit de créer une classe ayant une méthode acceptant un entier et retournant une valeur selon les exigences de FizzBuzz décrites plus haut.\n\nUn argument de 1 retourne 1.\nUn argument de 2 retourne 2.\nUn argument de 3 retourne Fizz.\nUn argument de 6 retourne Fizz.\nUn argument de 5 retourne Buzz.\nUn argument de 10 retourne Buzz.\nUn argument de 15 retourne FizzBuzz.\nUn argument de 30 retourne FizzBuzz.\nSupporter des exigences qui évoluent. Attention aux conflits dans les exigences :\n\nIl faut imprimer Fizz au lieu du nombre si le nombre est un multiple de 3 ou contient un 3 (ex. : 13 → Fizz).\nIl faut imprimer Buzz au lieu du nombre si le nombre est un multiple de 5 ou contient un 5 (ex. : 59 → Fizz).\nIl faut imprimer FizzBuzz si le nombre est un multiple de 5 et de 3 ou contient un 5 et un 3 (ex. : 53 → FizzBuzz).\n\n\n\n\n\n\nKarac, I., et Turhan, B. (2018). What Do We (Really) Know about Test-Driven Development? IEEE Software, 35(4), 81‑85. https://doi.org/10.1109/MS.2018.2801554"
  },
  {
    "objectID": "Réusinage.html#introduction",
    "href": "Réusinage.html#introduction",
    "title": "11  Réusinage (Refactorisation)",
    "section": "11.1 Introduction",
    "text": "11.1 Introduction\nConsidérez l’histoire suivante, provenant de la 2e édition du livre Refactoring de Fowler (2018) :\n\n\n\n\n\n\nIl était une fois un consultant qui a rendu visite à l’équipe d’un projet de développement afin de regarder une partie du code qui avait été écrit. En parcourant la hiérarchie des classes au centre du système, le consultant l’a trouvée plutôt désordonnée. Les classes de niveau supérieur ont émis certaines hypothèses sur la façon dont les classes fonctionneraient, hypothèses incorporées dans le code hérité. Ce code n’était pas cohérent avec toutes les sous-classes, cependant, et a été redéfini à beaucoup d’endroits. De légères modifications à la superclasse auraient considérablement réduit la nécessité de la redéfinir. À d’autres endroits, l’intention de la superclasse n’avait pas été bien comprise, et le comportement présent dans la superclasse était dupliqué. Dans d’autres endroits encore, plusieurs sous-classes avaient fait la même chose avec du code qui pouvait clairement être déplacé dans la hiérarchie.\nLe consultant a recommandé à la direction du projet que le code soit examiné et nettoyé, mais la direction du projet n’était pas enthousiaste. Le code semblait fonctionner, et il y avait des contraintes sur l’emploi du temps considérables. L’équipe de gestion a dit qu’elle y parviendraient ultérieurement.\nLe consultant a également montré ce qui se passait aux programmeurs et programmeuses travaillant sur la hiérarchie. Ils étaient enthousiastes et ont vu le problème. Ils savaient que ce n’était pas vraiment de leur faute : parfois, l’évaluation par une autre personne est nécessaire pour détecter le problème. Les programmeurs et programmeuses ont donc passé un jour ou deux à nettoyer la hiérarchie. Une fois qu’ils eurent terminé, ils avaient supprimé la moitié du code de la hiérarchie sans réduire sa fonctionnalité. Ils étaient satisfaits du résultat et ont constaté qu’il était devenu plus rapide et plus facile d’ajouter de nouvelles classes et d’utiliser les classes dans le reste du système.\nLa direction du projet n’était pas contente. L’échéancier était serré, et il y avait beaucoup de travail à faire. Ces programmeurs et programmeuses avaient passé deux jours à effectuer un travail qui n’ajoutait rien aux nombreuses fonctionnalités que le système devait offrir en quelques mois. L’ancien code avait très bien fonctionné. Oui, la conception était un peu plus « pure » et un peu plus « propre », mais le projet devait expédier du code qui fonctionnait, pas du code qui plairait à des universitaires. Le consultant a suggéré qu’un nettoyage similaire soit effectué sur d’autres parties centrales du système, ce qui pourrait interrompre le projet pendant une semaine ou deux. Tout cela était pour rendre le code plus beau, pas pour lui faire faire ce qu’il ne faisait pas déjà.\n\n\n\nCette histoire est un bon exemple des deux forces constamment en jeu lors d’un développement de logiciel. D’un côté, on veut que le code fonctionne (pour satisfaire les fonctionnalités) et, d’un autre côté, on veut que la conception soit acceptable puisqu’il y a d’autres exigences sur un logiciel telles que la maintenabilité, l’extensibilité, etc. La section sur le Spectre de la conception aborde cette dynamique.\nLe réusinage (en anglais refactoring) est, selon Fowler, « l’amélioration de la conception du code après avoir écrit celui-ci ». Il s’agit de retravailler le code source de façon à en améliorer la lisibilité ou la structure, sans en modifier le fonctionnement. C’est une manière de gérer la dette technique, car, grâce au réusinage, on peut transformer du code chaotique (écrit peut-être par les gens en mode « hacking cowboy ») en code bien structuré. De plus, beaucoup d’IDE supportent l’automatisation d’activités de réusinage, rendant le processus plus facile et robuste. Probablement que vous avez déjà « renommé » une variable dans le code source, à travers un menu « Refactoring ».\nLe réusinage est une activité intégrante du Développement piloté par les tests."
  },
  {
    "objectID": "Réusinage.html#symptômes-de-la-mauvaise-conception-code-smells",
    "href": "Réusinage.html#symptômes-de-la-mauvaise-conception-code-smells",
    "title": "11  Réusinage (Refactorisation)",
    "section": "11.2 Symptômes de la mauvaise conception – Code smells",
    "text": "11.2 Symptômes de la mauvaise conception – Code smells\nEn anglais, le terme « Code smell » a été proposé par Fowler pour les symptômes d’une mauvaise conception. Le but est de savoir à quel moment il faut effectuer des activités de réusinage.\nPar exemple, le premier « smell » dans son livre est « Mysterious Name ». Il apparaît lorsqu’on voit une variable ou une méthode dont le nom est incohérent avec son utilisation. Cela arrive puisqu’il n’est pas toujours facile de trouver un bon nom au moment où l’on est en train d’écrire du code. Plutôt que de buter sur le choix, on met un nom arbitraire (ou peut-être que, par naïveté, on se trompe carrément de nom). Alors, si vous observez ce problème (smell) dans un logiciel, vous n’avez qu’à appliquer l’activité de réusinage nommée Change Function Declaration, Rename Field ou Rename Variable, selon le cas.\nUn autre exemple de mauvaise conception est un programme assez complexe, mais avec seulement une ou deux classes. Ces classes ont beaucoup d’attributs et de méthodes. Alors, ce « smell » s’appelle « Large Class », et la solution est d’appliquer des activités de réusinage Extract Class, ou éventuellement Extract Superclass ou Replace Type Code with Subclasses. Avec un IDE dominant et un langage populaire, vous aurez probablement des fonctionnalités pour supporter l’automatisation de ces activités de réusinage.\nCertaines activités traitent des sujets avancés en conception, mais c’est très intéressant pour ceux et celles qui aiment le bon design. Voici la liste complète des « smells » ainsi que des activités de réusinage à appliquer (voir le catalogue sur le site Web https://refactoring.com/catalog/ pour les détails).\n\n\n\nSymptôme de mauvaise conception (« Smell »)\nActivités de réusinage à appliquer éventuellement\n\n\n\n\nMysterious Name\nChange Function Declaration, Rename Variable, Rename Field\n\n\nDuplicated Code\nExtract Function, Slide Statements, Pull Up Method\n\n\nLong Function\nExtract Function, Replace Temp with Query, Introduce Parameter Object, Preserve Whole Object, Replace Function with Command, Decompose Conditional, Replace Conditional with Polymorphism, Split Loop\n\n\nLong Parameter List\nReplace Parameter with Query, Preserve Whole Object, Introduce Parameter Object, Remove Flag Argument, Combine Functions into Class\n\n\nGlobal Data\nEncapsulate Variable\n\n\nMutable Data\nEncapsulate Variable, Split Variable, Slide Statements, Extract Function, Separate Query from Modifier, Remove Setting Method, Replace Derived Variable with Query, Use Combine Functions into Class, Combine Functions into Transform, Change Reference to Value\n\n\nDivergent Change\nSplit Phase, Move Function, Extract Function, Extract Class\n\n\nShotgun Surgery\nMove Function, Move Field, Combine Functions into Class, Combine Functions into Transform, Split Phase, Inline Function, Inline Class\n\n\nFeature Envy\nMove Function, Extract Function\n\n\nData Clumps\nExtract Class, Introduce Parameter Object, Preserve Whole Object\n\n\nPrimitive Obsession\nReplace Primitive with Object, Type Code with Subclasses, Replace Conditional with Polymorphism, Extract Class, Introduce Parameter Object\n\n\nRepeated Switches\nReplace Conditional with Polymorphism\n\n\nLoops\nReplace Loop with Pipeline\n\n\nLazy Element\nInline Function, Inline Class, Collapse Hierarchy\n\n\nSpeculative Generality\nCollapse Hierarchy, Inline Function, Inline Class, Change Function Declaration, Remove Dead Code\n\n\nTemporary Field\nExtract Class, Move Function, Introduce Special Case\n\n\nMessage Chains\nHide Delegate, Extract Function, Move Function\n\n\nMiddle Man\nRemove Middle Man, Inline Function, Replace Superclass with Delegate, Replace Subclass with Delegate\n\n\nInsider Trading\nMove Function, Move Field, Hide Delegate, Replace Subclass with Delegate, Replace Superclass with Delegate\n\n\nLarge Class\nExtract Class, Extract Superclass, Replace Type Code with Subclasses\n\n\nAlternative Classes with Different Interfaces\nChange Function Declaration, Move Function, Extract Superclass\n\n\nData Class\nEncapsulate Record, Remove Setting Method, Move Function, Extract Function, Split Phase\n\n\nRefused Bequest\nPush Down Method, Push Down Field, Replace Subclass with Delegate, Replace Superclass with Delegate\n\n\nComments\nExtract Function, Change Function Declaration, Introduce Assertion"
  },
  {
    "objectID": "Réusinage.html#automatisation-du-réusinage-par-les-ide",
    "href": "Réusinage.html#automatisation-du-réusinage-par-les-ide",
    "title": "11  Réusinage (Refactorisation)",
    "section": "11.3 Automatisation du réusinage par les IDE",
    "text": "11.3 Automatisation du réusinage par les IDE\nLe sujet du réusinage est abordé par Larman (2005) à la section F19.2/A22.2 . Il y a plusieurs exemples de base détaillés qui sont automatisés par les IDE dominants tels que Eclipse, IntelliJ IDEA, WebStorm, JetBrains PyCharm, Visual Studio Code, etc. Il se peut que, dans un avenir proche, le réusinage (l’amélioration du design) devienne une activité réalisée par des algorithmes d’intelligence artificielle.\nPour plus d’activités de réusinage, il y a le catalogue du site refactoring.com.\nVoir cette page Web pour savoir comment les activités de réusinage sont faites dans Visual Studio Code. D’autres automatisations sont implémentées par des extensions."
  },
  {
    "objectID": "Réusinage.html#impropriété",
    "href": "Réusinage.html#impropriété",
    "title": "11  Réusinage (Refactorisation)",
    "section": "11.4 Impropriété",
    "text": "11.4 Impropriété\nSi quelqu’un dit que son code est cassé pendant plusieurs jours parce qu’il fait du réusinage, ce n’est pas la bonne utilisation du terme selon Martin Fowler. Il s’agit de restructuration dans ce cas.\nLe réusinage est basé sur les petites transformations qui ne changent pas le comportement du logiciel.\n\n\n\n\nFowler, M. (2018). Refactoring: Improving the Design of Existing Code (2ᵉ éd.). Boston : Addison-Wesley Professional.\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "TravailEquipe.html#humilité-respect-confiance-hrc",
    "href": "TravailEquipe.html#humilité-respect-confiance-hrc",
    "title": "12  Développement de logiciels en équipe",
    "section": "12.1 Humilité, respect, confiance (HRC)",
    "text": "12.1 Humilité, respect, confiance (HRC)\nL’humilité, le respect et la confiance (voir la figure 12.1) sont les qualités de base pour le bon travail en équipe. Souvenez-vous-en grâce au sigle HRC. Cette section présente ces aspects en détail.\n\n\n\nFigure 12.1: Pratiquement tout conflit social est dû à un manque d’humilité, de respect ou de confiance.\n\n\n\n12.1.1 Humilité\nVoici la définition d’humilité selon Antidote :\n\n\n\n\n\n\nDisposition à s’abaisser volontairement, par sentiment de sa propre faiblesse.\n\n\n\nUne personne humble pense ainsi (Fitzpatrick et Collins-Sussman, 2012) :\n\nJe ne suis pas le centre de l’univers.\nJe ne suis ni omnisciente ni infaillible.\nJe suis ouverte à m’améliorer.\n\n\n\n\n\n\n\nImportant\n\n\n\nL’humilité ne veut pas dire « je n’ai pas de valeur » ou « j’accepte les attaques de la part des autres ». Voir la section Proposer des solutions au besoin.\n\n\n\n\n\n\n\n\n\n(a) Éviter d’être le « Centre de l’univers » (CC BY-NC-ND 2.0) par Diamondduste.\n\n\n\n\n \n\n\n\n\n\n(b) Savoir qu’on n’est pas infaillible. « Brown Eyed Susan » (CC BY-NC-ND 2.0) par dbarronoss.\n\n\n\n\n \n\n\n\n\nÉquipe > Moi\n(c) Une personne humble va accepter une décision prise par l’équipe, même si elle n’est pas en accord à 100%.\n\n\n\n\nFigure 12.2: Métaphores pour l’humilité.\n\n\nQuelques exemples concrets de comportements reflétant la qualité d’humilité chez les développeurs ou développeuses :\n\nLes membres de l’équipe qui n’ont pas le niveau d’expertise requis pour un projet vont le reconnaître et vont même faire des efforts pour s’améliorer et se mettre à niveau. Par exemple, une personne avec un niveau débutant en JavaScript, Git, etc. va faire des exercices et/ou suivre des formations sur Internet pour s’améliorer.\nLes membres de l’équipe (même la ou le chef) qui ont pris une mauvaise décision (technique ou autre) vont l’avouer. Elles et ils savent que les autres ne sont pas là pour les attaquer (il y a du respect).\nUn ou une membre de l’équipe va travailler fort pour que son équipe réussisse.\nUn ou une membre de l’équipe qui reçoit une critique ne va pas la prendre personnellement. Il ou elle sait que la qualité de son code n’équivaut pas à son estime de soi (cela n’est pas toujours facile !)\n\n\n\n12.1.2 Respect\nUne personne démontrant du respect pense ainsi (Fitzpatrick et Collins-Sussman, 2012) :\n\nJe me soucie des gens avec qui je travaille.\nJe les traite comme des êtres humains.\nJ’ai de l’estime pour leurs capacités et leurs réalisations.\n\n\n\n12.1.3 Confiance\nUne personne démontrant de la confiance pense ainsi (Fitzpatrick et Collins-Sussman, 2012) :\n\nJe crois que les autres membres de l’équipe font preuve de compétence et de bon jugement.\nJe suis à l’aise lorsque les autres (membres de l’équipe) prennent le volant, le cas échéant.\n\nLe dernier point peut être extrêmement difficile si, par le passé, une personne (incompétente) à qui vous aviez délégué une tâche n’a pas répondu à vos attentes."
  },
  {
    "objectID": "TravailEquipe.html#sec-Bus_Factor",
    "href": "TravailEquipe.html#sec-Bus_Factor",
    "title": "12  Développement de logiciels en équipe",
    "section": "12.2 Redondance des compétences dans l’équipe (bus factor)",
    "text": "12.2 Redondance des compétences dans l’équipe (bus factor)\nPour qu’une équipe soit robuste, il faut une redondance des compétences. Sinon, la perte soudaine d’un ou d’une membre de l’équipe (pour une raison quelconque) peut engendrer de graves conséquences, voire l’arrêt du projet. Ce principe a été nommé bus factor en anglais, faisant référence au nombre de personnes clés dans votre équipe pouvant se faire renverser par un autobus pour arrêter le projet par manque de personnel bien informé ou compétent. Par exemple, dans un projet de stage, si c’est vous qui écrivez tout le code, alors c’est un bus factor de 1. Si vous n’êtes plus là, le projet s’arrête !\n\n\n\nBus factor (nom) : le nombre de personnes qui doivent être heurtées par un autobus avant que votre projet ne soit complètement condamné (Fitzpatrick et Collins-Sussman, 2012). « Male and Female software engineers in front of a bus at a crosswalk, flat lighting, tilt shift photography » par Cris × DALL·E.\n\n\nUn ou une membre de l’équipe peut s’absenter ou être moins disponible soudainement pour beaucoup de raisons. Par exemple, cette personne part en vacances, tombe malade, prend un congé parental, change d’emploi, abandonne le cours (contexte de projet universitaire), etc. Cherchez à répartir les responsabilités dans l’équipe afin d’avoir un bus factor d’au moins 2. Partagez des compétences pour maintenir une équipe robuste et polyvalente.\nVous pouvez également garder votre projet simple en réduisant les technologies, car chaque dimension technologique (langage, cadriciel, environnement) nécessite une compétence technique à cause des complexités et des dépendances. Il est important de garder la documentation de votre conception à jour, surtout les raisons pour lesquelles certains choix technologiques ont été faits. Si une personne a choisi un cadriciel, par exemple, mais qu’elle n’est plus là pour vous dire pourquoi, c’est une information perdue. L’automatisation des tests dans un processus de construction de logiciels (build process) à la devops (Chapitre 10) aide aussi, car l’équipe ne dépend pas d’une personne pour construire la solution, rouler les tests, etc. Les configurations devops et les tests sont en fait une forme de documentation. Toutes ces pratiques vont également faciliter l’intégration de nouvelles personnes dans l’équipe.\n\n\n\n\n\n\nAvertissement\n\n\n\nDans un contexte universitaire, si un ou une membre de l’équipe s’absente ou abandonne soudainement, il n’est pas facile de maintenir le même rythme. Cependant, les enseignantes ou enseignants et les auxiliaires de laboratoire s’attendront à ce que vous ayez pensé à un « plan B » pour faire face à ce contretemps. Au moins une autre personne dans l’équipe doit être au courant de ce que faisait l’ex-membre de l’équipe, pour que le projet ne soit pas complètement arrêté."
  },
  {
    "objectID": "TravailEquipe.html#mentorat",
    "href": "TravailEquipe.html#mentorat",
    "title": "12  Développement de logiciels en équipe",
    "section": "12.3 Mentorat",
    "text": "12.3 Mentorat\nPour des raisons pédagogiques (Oakley, Felder, Brent, et Elhajj, 2004), c’est l’enseignant ou l’enseignante qui décide la composition des équipes. Ça veut dire que, forcément, certaines personnes de l’équipe ont plus d’expérience et de facilité à faire certaines tâches que d’autres. Les équipes doivent composer avec cette diversité.\nSelon Fitzpatrick et Collins-Sussman (2012) :\n\n\n\n\n\n\nSi vous avez déjà un bon bagage en programmation, ça peut être pénible de voir une autre personne moins expérimentée dans l’équipe tenter un travail qui lui prendra beaucoup de temps lorsque vous savez que ça vous prendrait juste quelques minutes. Apprendre à quelqu’un comment faire une tâche et lui donner l’occasion d’évoluer tout seul sont un défi au début, mais cela est une caractéristique importante du leadership.\n\n\n\nSi les personnes plus fortes n’aident pas les autres, elles risquent de les éloigner de l’équipe et de se retrouver seules sur le plan des contributions techniques. Voir la section sur la Redondance des compétences dans l’équipe (bus factor).\nEncadrer un ou une membre de l’équipe au début du trimestre peut prendre beaucoup de temps. Mais, si la personne devient plus autonome, c’est un gain pour toute l’équipe. Cela augmente également le bus factor.\nVoici quelques conseils pour le mentorat :\n\navoir les compétences sur un plan technique ;\nêtre capable d’expliquer des choses à quelqu’un d’autre ;\nsavoir évaluer le besoin de la personne à encadrer dans l’équipe, pour bien quantifier l’aide que vous allez lui fournir.\n\nLe dernier point est important parce que, si vous donnez trop d’informations à la personne, elle peut vous ignorer plutôt que de vous dire gentiment qu’elle a compris (Fitzpatrick et Collins-Sussman, 2012). En plus, donner un faible niveau d’orientation ou de directives à une personne ayant déjà de l’expérience est plus efficace que donner une orientation explicite (Chen, Kalyuga, et Sweller, 2017 ; Oakley et Sejnowski, 2021). Un bon mentor ou une bonne mentore doit pouvoir estimer le niveau de la personne et lui donner l’aide appropriée, ce qui n’est pas toujours facile. Mais sachez que « moins est plus » dans certains cas.\n\n\n\nSavoir encadrer les membres de l’équipe est une habileté à mettre sur son CV. « CultureTECH BT Monster Dojo » (CC BY 2.0) par connor2nz."
  },
  {
    "objectID": "TravailEquipe.html#scénarios",
    "href": "TravailEquipe.html#scénarios",
    "title": "12  Développement de logiciels en équipe",
    "section": "12.4 Scénarios",
    "text": "12.4 Scénarios\nConsidérez les volets HRC lorsque vous vous trouvez dans une des situations suivantes (il s’agit de projets dans un contexte de cours, mais certains scénarios peuvent aussi arriver dans les équipes professionnelles) :\n\nUne personne dans l’équipe se trouve à être la seule à faire de la programmation.\n\nElle ne fait plus confiance aux autres membres de l’équipe, car leur code est trop bogué.\nElle n’a pas la patience pour accommoder les membres de l’équipe avec moins d’expérience.\nElle croit que les autres auraient dû apprendre à mieux programmer dans les cours préalables.\n\nUne personne dans l’équipe dit qu’elle a « fait ses trois heures de contribution » chaque dimanche chez elle et que ça devrait suffire pour sa partie (elle a un emploi et n’a pas beaucoup de temps pour l’équipe du projet universitaire).\nUn ou deux membres d’une équipe abandonnent le cours après les évaluations de mi-trimestre, par crainte d’échouer à leur cours.\nUn ou une membre de l’équipe suit cinq ( !) cours en même temps et n’a pas le temps suffisant pour travailler correctement dans les laboratoires de cette matière.\nPlusieurs membres de l’équipe ont de l’expérience, mais ont de la difficulté à s’entendre sur l’orientation du projet.\nL’équipe n’est pas cohésive : chaque membre fait avancer sa partie, mais le code ne fonctionne pas ensemble.\n\nVous devez en parler avec votre équipe, avec humilité, respect et confiance. Si la situation ne s’améliore pas, vous devez en parler avec une personne ressource, comme votre superviseur ou votre superviseuse (en stage), les auxiliaires de laboratoire ou l’enseignant ou l’enseignante.\nDes conseils pour mieux évaluer le travail de chaque membre dans l’équipe au laboratoire sont présentés dans la section Évaluer les contributions des membres de l’équipe."
  },
  {
    "objectID": "TravailEquipe.html#résumé",
    "href": "TravailEquipe.html#résumé",
    "title": "12  Développement de logiciels en équipe",
    "section": "12.5 Résumé",
    "text": "12.5 Résumé\nLe travail en équipe est essentiel pour une personne qui développe des logiciels. Le respect, l’humilité et la confiance (HRC) sont des notions importantes du comportement humain lorsqu’on travaille en équipe. Développer les compétences dans cette dimension (les soft skills) est un défi, mais l’investissement est payant à long terme. Ça vaut autant (voire plus) que les compétences dans des technologies qui risquent toujours d’être désuètes dans dix ans ou moins.\n\n\n\n\nBoittiaux, P. (2016, 13 décembre). Infographie: Le Web dit adieu à Flash. Statista Infographies. Repéré à https://fr.statista.com/infographie/7186/le-web-dit-adieu-a-flash/\n\n\nChen, O., Kalyuga, S., et Sweller, J. (2017). The expertise reversal effect is a variant of the more general element interactivity effect. Educational Psychology Review, 29(2), 393‑405.\n\n\nFitzpatrick, B. W., et Collins-Sussman, B. (2012). Team Geek: A Software Developer’s Guide to Working Well with Others (1ʳᵉ éd.). Sebastopol. CA : O’Reilly Media.\n\n\nOakley, B., Felder, R. M., Brent, R., et Elhajj, I. (2004). Turning student groups into effective teams. Journal of student centered learning, 2(1), 9‑34.\n\n\nOakley, B., et Sejnowski, T. J. (2021). Uncommon sense teaching: Practical insights in brain science to help students learn. (S.l.) : Penguin."
  },
  {
    "objectID": "Outils-UML.html#exemples-de-diagrammes-avec-plantuml",
    "href": "Outils-UML.html#exemples-de-diagrammes-avec-plantuml",
    "title": "13  Outils pour la modélisation UML",
    "section": "13.1 Exemples de diagrammes avec PlantUML",
    "text": "13.1 Exemples de diagrammes avec PlantUML\nDans le menu « Select sample diagram » de PlantUML Gizmo (Google Docs), il y a plusieurs exemples de diagrammes utilisés dans le cadre de ce manuel et du livre de Larman (2005) (voir la figure 13.4)."
  },
  {
    "objectID": "Outils-UML.html#astuces-plantuml",
    "href": "Outils-UML.html#astuces-plantuml",
    "title": "13  Outils pour la modélisation UML",
    "section": "13.2 Astuces PlantUML",
    "text": "13.2 Astuces PlantUML\n\nComment intégrer PlantUML dans le Readme.md de GitHub/GitLab ? \nLe serveur de PlantUML.com génère un diagramme à partir d’une URL,\nhttps://plantuml.com/plantuml/{forme}/{clé}, qui contient une clé comme\nSoWkIImgAStDuKfKqBLJI5AmKaZcSaZDIm4A0G00.\nLa clé est en fait une représentation compressée du code source.\nOn peut changer la forme du diagramme en changeant la partie {forme} de l’URL :\n\n{forme} → png, img ou svg : représentation graphique correspondante ;\n{forme} → uml : récupération du code source PlantUML.\n\nOn peut également récupérer localement le code source d’une URL avec l’outil PlantUML avec l’option -decodeurl {clé} de la ligne de commande :\n\n$ java -jar plantuml.jar -decodeurl SoWkIImgAStDuKfKqBLJI5AmKaZcSaZDIm4A0G00\n@startuml\na -> b : c\n@enduml\n\nLes images png générées par le serveur ou par l’outil contiennent une copie du code source dans les métadonnées PNG.\n\nOn peut récupérer le code source PlantUML à partir d’une image PNG avec un outil sur le Web comme https://exifinfo.org/.\nOn peut également utiliser l’option -metadata de la ligne de commande PlantUML :\n\n$ java -jar plantuml.jar -metadata diagram.png > diagram.puml\n\n\n\n\nFigure 13.3: PlantUML Gizmo pour Google Docs et Google Slides.\n\n\n\n\n\nFigure 13.4: PlantUML Gizmo offre plusieurs exemples de diagrammes UML.\n\n\n\n\n\nFigure 13.5: Exemple de tentative de créer un diagramme de séquence système (DSS) avec Lucidchart. C’est principalement un éditeur graphique avec les éléments graphiques UML qui sont essentiellement des éléments graphiques composés. Il n’y a pas de sémantique UML dans l’outil. Par exemple, un « message » UML dans un diagramme de séquence dans Lucidchart est juste une ligne groupée avec un texte. Elle peut se coller dynamiquement à d’autres éléments en se transformant en courbe ( !) lorsque vous déplacez un bloc « loop ». La ligne de vie de l’acteur Étudiant se transforme en diagonale lorsque l’acteur est déplacé à droite. Un vrai message UML est normalement toujours à l’horizontale, et une vraie ligne de vie est toujours à la verticale. Puisque Lucidchart ne connaît pas cette sémantique, vous risquez de perdre beaucoup de temps à faire des diagrammes UML avec ce genre d’outil.\n\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "GRASP-GoF.html#exemple-avec-adaptateur",
    "href": "GRASP-GoF.html#exemple-avec-adaptateur",
    "title": "14  Décortiquer les patterns GoF avec GRASP",
    "section": "14.1 Exemple avec Adaptateur",
    "text": "14.1 Exemple avec Adaptateur\nLe pattern Adaptateur a été proposé par Gamma, Helm, Johnson, et Vlissides (1994), et sa structure est illustrée sur la figure 14.1. La structure de base peut être trompeuse, car elle ne montre qu’une seule classe Adaptee qui représente l’interface API (externe) que l’on ne peut modifier. En réalité, ce pattern est plus intéressant lorsqu’on considère plusieurs cas de classe Adaptee, chacune avec une interface API différente.\n\n\n\n\n\n\nQu’est-ce qu’un calculateur de taxes ?\n\n\n\nOn rappelle ici le contexte du problème auquel a été appliqué le pattern Adaptateur, soit le problème de calcul des taxes. Le logiciel NextGen POS doit calculer les taxes pour les ventes, mais la compagnie vise un marché large (par exemple, les États-unis et le Canada). Puisque le calcul des taxes peut être différent selon l’État et même la ville (par exemple les villes de la Californie), la compagnie qui développe NextGen POS ne veut pas maintenir toute cette information dans une partie du logiciel, car la maintenance ne sera pas rentable. La solution est de permettre au système d’exploiter un module externe qui est un « calculateur de taxes », car ce genre de module existe (voir TaxCloud). Puisque la clientèle du NextGen POS pourrait utiliser des calculateurs différents (selon sa région ou son budget), il faut constater que l’interface API de chaque calculateur sera différente (faute de norme sur les interfaces API de calculateurs de taxe) et immuable (on ne peut pas s’attendre à ce que le fournisseur de chaque calculateur change son interface API ou fournisse le code source). Alors, le pattern Adaptateur est proposé comme solution à ce problème. Larman (2005) propose aussi que les modules externes soient considérés pour gérer l’inventaire et pour suivre la comptabilité, car ces fonctionnalités sont complexes et difficiles à faire correctement. Encore, si NextGen POS supporte plusieurs choix (fournisseurs) de ces modules externes, il y aura ensuite le problème des interfaces API différentes et immuables. Le pattern Adaptateur sera encore utile dans ce contexte.\n\n\nLe chapitre A26/F23  présente l’exemple du pattern Adaptateur pour les calculateurs de taxes (figure F23.1/A26.1 ). On remarque que cette figure dans le livre de Larman ne montre pas les classes adaptées, mais nous les avons ajoutées dans la figure 14.2. Nous faisons une hypothèse sur les noms des méthodes pour l’interface API des classes adaptées, car cette information n’est pas spécifiée. En plus, nous n’avons pas spécifié les arguments (c’est « ? »), car les détails ne sont pas connus.\nUn autre point à mentionner dans le problème de calcul des taxes est que ça dépend de l’article. Selon l’État ou la province, certains articles sont sujets à des taxes et d’autres non. A priori, le calculateur de taxes est l’expert pour décider combien de taxes pour chaque article, mais le calculateur n’est pas l’expert des articles. C’est pour cela que l’Adaptateur a accès à l’objet Vente qui agrège des LigneArticles. L’Adaptateur de calculateur de taxes pourra ainsi accéder à chaque article de la vente pour déterminer les taxes. L’objet Vente a une visibilité de paramètre.\nDans le contexte du projet NextGen POS, Larman propose l’utilisation de ce pattern pour plusieurs dimensions où des services externes ont plusieurs possibilités (l’inventaire, la comptabilité, etc.).\n\n\nTargetRequest()AdapterRequest()adaptee -> SpecificRequest()AdapteeSpecificRequest()Clientadaptee\nFigure 14.1: Le diagramme de classes du pattern Adaptateur (Gamma et coll., 1994).\n\n\n\n\n« interface »IAdaptateurCalculTaxesgetTaxes( Vente ) : Liste de LigneTaxesAdaptateurTaxMastergetTaxes( Vente ) : Liste de LigneTaxesAdaptateurGoodAsGoldTaxProgetTaxes( Vente ) : Liste de LigneTaxesTaxMastercalculateTaxes ( ? )GoodAsGoldTaxProcomputeTaxes ( ? )\nFigure 14.2: Le pattern Adaptateur appliqué pour les services externes de calculateurs de taxes. Chaque service externe a une interface API distincte et immuable. Les adaptateurs concrets permettent de normaliser l’accès à ces interfaces API à travers une interface IAdaptateurCalculTaxes."
  },
  {
    "objectID": "GRASP-GoF.html#imaginer-le-code-sans-le-pattern-gof",
    "href": "GRASP-GoF.html#imaginer-le-code-sans-le-pattern-gof",
    "title": "14  Décortiquer les patterns GoF avec GRASP",
    "section": "14.2 Imaginer le code sans le pattern GoF",
    "text": "14.2 Imaginer le code sans le pattern GoF\nChaque principe GRASP est défini avec un énoncé d’un problème de conception et avec une solution pour le résoudre. Pourtant, beaucoup d’exemples dans le livre de Larman (2005) sont des patterns GoF déjà appliqués (et le problème initial n’est pas toujours expliqué en détail).\nAlors, pour mieux comprendre l’application des patterns GoF, on doit imaginer la situation du logiciel avant l’application du pattern. Dans l’exemple avec l’adaptateur pour les calculateurs de taxes, imaginez le code si l’on n’avait aucun adaptateur. À la place d’une méthode getTaxes() envoyée par la classe Vente à l’adaptateur, on aurait l’obligation de faire un branchement selon le type de calculateur de taxes externe utilisé actuellement (si l’on veut supporter plusieurs calculateurs). Donc, dans la classe Vente, il y aurait du code comme ceci :\n/* calculateurTaxes est le nom du calculateur utilisé actuellement */\nif (calculateurTaxes == \"GoodAsGoldTaxPro\") {\n    /* série d'instructions pour interagir avec GoodAsGoldTaxPro */\n} else if (calculateurTaxes == \"TaxMaster\") {\n    /* série d'instructions pour interagir avec TaxMaster */\n} else if /* ainsi de suite pour chacun des calculateurs */\n    /* ... */\n}\nPour supporter un nouveau calculateur de taxes, il faudrait coder une nouvelle branche dans le bloc de if/then. Ça nuirait à la clarté du code, et la méthode qui contient tout ce code deviendrait de plus en plus longue. Même si l’on faisait une méthode pour encapsuler le code de chaque branche, ça ferait toujours augmenter les responsabilités de la classe Vente. Elle est responsable de connaître tous les détails (l’interface API distincte et immuable) de chaque calculateur de taxes externe, puisqu’elle communique directement (il y a du couplage) avec ces derniers. Lorsqu’une classe prend plus de responsabilités, ça porte atteinte à sa cohésion.\nLe pattern Adaptateur comprend les principes GRASP Faible Couplage, Forte Cohésion, Polymorphisme, Indirection, Fabrication Pure et Protection des variations. La figure 14.3 démontre la relation entre ces principes dans le cas d’Adaptateur.\n\n\n   AdaptateurPatternsGoFMécanisme deProtection desvariationsMécanisme deFaible CouplageMécanisme deForte CohésionExemple dePolymorphismeMécanismed'IndirectionFabricationPurePrincipesGRASPFaible Couplage est une façon d'obtenir une protection à un point de variation. Polymorphisme est une façon d'obtenir une protection à un point de variationet un faible couplage. Une Indirection est une façon d'obtenir un faible couplage. Le pattern Adaptateur est une sorte d'Indirection et de Fabrication Pure quiapplique le principe de Polymorphisme.\nFigure 14.3: Adaptateur et principes GRASP (figure F23.3/A26.3 ).\n\n\nOn peut donc voir le pattern Adaptateur comme une spécialisation de plusieurs principes GRASP :\n\nPolymorphisme\nIndirection\nFabrication Pure\nFaible Couplage\nForte Cohésion\nProtection des variations\n\nAvec cette identification de principes GRASP dans le pattern Adaptateur, êtes-vous en mesure d’expliquer en détail avec ce contexte concret comment Adaptateur est relié à ces principes ?"
  },
  {
    "objectID": "GRASP-GoF.html#sec-GRASP_Adaptateur",
    "href": "GRASP-GoF.html#sec-GRASP_Adaptateur",
    "title": "14  Décortiquer les patterns GoF avec GRASP",
    "section": "14.3 Identifier les GRASP dans les GoF",
    "text": "14.3 Identifier les GRASP dans les GoF\nPour identifier les principes GRASP dans un pattern GoF comme Adaptateur, on rappelle la définition de chaque principe GRASP et l’on essaie d’imaginer le problème qui pourrait exister éventuellement. Ensuite, on explique comment le principe (et le pattern GoF) résout le problème.\nConsultez la figure 14.2 du pattern Adaptateur pour les sections suivantes.\n\n14.3.1 Polymorphisme\nSelon Larman (2005) :\n\n\n\n\n\n\nProblème : Qui est responsable quand le comportement varie selon le type ?\nSolution : Lorsqu’un comportement varie selon le type (classe), affectez la responsabilité de ce comportement – avec des opérations polymorphes – aux types selon lesquels le comportement varie.\n\n\n\nLe « comportement qui varie » est la manière d’adapter les méthodes utilisées par le calculateur de taxes choisi à la méthode getTaxes(). Alors, cette « responsabilité » est affectée au type interface IAdaptateurCalculTaxes (et à ses implémentations) dans l’opération polymorphe getTaxes(). Cet aspect du pattern est illustré sur la figure 14.4.\n\n\n\nFigure 14.4: Le mécanisme de Polymorphisme dans le pattern Adaptateur appliqué au problème de calculateurs de taxes. getTaxes(...) est un appel polymorphe. Selon la configuration du système (l’objet auquel IAdaptateurCalculTaxes fait référence), le comportement sera différent.\n\n\n\n\n14.3.2 Fabrication Pure\nSelon Larman (2005) :\n\n\n\n\n\n\nProblème : En cas de situation désespérée, que faire quand vous ne voulez pas transgresser les principes de faible couplage et de forte cohésion ?\nSolution : Affectez un ensemble très cohésif de responsabilités à une classe « comportementale » artificielle qui ne représente pas un concept du domaine – une entité fabriquée pour augmenter la cohésion, diminuer le couplage et faciliter la réutilisation.\n\n\n\nLa Fabrication Pure est la classe « comportementale et artificielle » qui est la hiérarchie IAdaptateurCalculTaxes (comprenant chaque adaptateur concret). Elle est comportementale puisqu’elle ne fait qu’adapter des appels. Elle est artificielle puisqu’elle ne représente pas un élément dans le modèle du domaine.\nL’ensemble des adaptateurs concrets ont des « responsabilités cohésives » qui sont la manière d’adapter la méthode getTaxes() aux méthodes (immuables) des calculateurs de taxes externes. Elles ne font que ça. La cohésion est augmentée aussi dans la classe Vente, qui n’a plus la responsabilité de s’adapter aux calculateurs de taxes externes. C’est le travail qui a été donné aux adaptateurs concrets.\nLe couplage est diminué, car la classe Vente n’est plus couplée directement aux calculateurs de taxes externes. La réutilisation des calculateurs est facilitée, car la classe Vente ne doit plus être modifiée si l’on veut utiliser un autre calculateur externe. Il suffit de créer un adaptateur pour ce dernier.\n\n\n14.3.3 Indirection\nSelon Larman (2005) :\n\n\n\n\n\n\nProblème : Comment affecter les responsabilités pour éviter le couplage direct ?\nSolution : Pour éviter le couplage direct, affectez la responsabilité à un objet qui sert d’intermédiaire avec les autres composants ou services.\n\n\n\nLe « couplage direct » qui est évité est le couplage entre la classe Vente et les calculateurs de taxes externes. Le pattern Adaptateur (général) cherche à découpler le Client des classes nommées Adaptee, car chaque Adaptee a une interface API différente pour le même genre de « service ». Alors, la responsabilité de s’adapter aux services différents est affectée à la hiérarchie de « classes intermédiaires », soit l’interface type IAdaptateurCalculTaxes et ses implémentations.\n\n\n14.3.4 Protection des variations\nSelon Larman (2005) :\n\n\n\n\n\n\nProblème : Comment affecter les responsabilités aux objets, aux sous-systèmes et aux systèmes de sorte que les variations ou l’instabilité de ces éléments n’aient pas d’impact négatif sur les autres ?\nSolution : Identifiez les points de variation ou d’instabilité prévisibles et affectez les responsabilités afin de créer une « interface » stable autour d’eux.\n\n\n\nLes « variations » ou « l’instabilité » sont les calculateurs de taxes qui ne sont pas sous le contrôle des développeurs et développeuses du projet (ce sont des modules externes ayant chacun une interface API différente). Quant à l’« impact négatif sur les autres », il s’agit des modifications qu’auraient à faire les développeurs et développeuses sur la classe Vente chaque fois que l’on décide de supporter un autre calculateur de taxes (ou si l’interface API de ce dernier évolue).\nQuant aux « responsabilités » à affecter, c’est la fonctionnalité commune de tous les calculateurs de taxes, soit le calcul de taxes. Pour ce qui est de l’« interface stable », il s’agit de la méthode getTaxes(), qui ne changera (probablement) jamais. Elle est définie dans l’interface type IAdaptateurCalculTaxes. Cette définition isole (protège) la classe Vente des modifications (ajout de nouveaux calculateurs ou changements de leur interface API)."
  },
  {
    "objectID": "GRASP-GoF.html#grasp-et-réusinage",
    "href": "GRASP-GoF.html#grasp-et-réusinage",
    "title": "14  Décortiquer les patterns GoF avec GRASP",
    "section": "14.4 GRASP et réusinage",
    "text": "14.4 GRASP et réusinage\nIl y a des liens entre les GRASP et les activités de Réusinage (Refactorisation). Alors, un IDE qui automatise les réusinages peut vous aider à appliquer certains GRASP.\n\nGRASP Polymorphisme est relié à Replace Type Code with Subclasses et à Replace Conditional with Polymorphism – attention, il vaut mieux appliquer ce dernier seulement quand il y a des instructions conditionnelles (switch) répétées à plusieurs endroits dans le code.\nGRASP Fabrication Pure est relié à Extract Class.\nGRASP Indirection est relié à Extract Function et à Move Function."
  },
  {
    "objectID": "GRASP-GoF.html#exercices",
    "href": "GRASP-GoF.html#exercices",
    "title": "14  Décortiquer les patterns GoF avec GRASP",
    "section": "14.5 Exercices",
    "text": "14.5 Exercices\nPour ces exercices, suivez le modèle pour décortiquer le pattern Adaptateur, illustré à la figure 14.3.\nUne bonne ressource pour les patterns GoF est la suivante :\nhttps://fuhrmanator.github.io/oodp-horstmann/htm/index_fr_en.html\n\n\n\n\n\n\nAstuce\n\n\n\nIl se peut que certains principes GRASP ne s’appliquent pas à un pattern GoF !\n\n\n\nExercice 14.1 (Itérateur) Identifiez les 4 principes GRASP dans le pattern Itérateur, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.2 (Observateur) Identifiez les 4 principes GRASP dans le pattern Observateur, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.3 (Stratégie) Identifiez les 4 principes GRASP dans le pattern Stratégie, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.4 (Composite) Identifiez les 4 principes GRASP dans le pattern Composite, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.5 (Décorateur) Identifiez les 4 principes GRASP dans le pattern Décorateur, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.6 (Méthode Template) Identifiez les 4 principes GRASP dans le pattern Méthode Template, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.7 (Commande) Identifiez les 4 principes GRASP dans le pattern Commande, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.8 (Méthode Fabrique) Identifiez les 4 principes GRASP dans le pattern Méthode de fabrique, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.9 (Proxy) Identifiez les 4 principes GRASP dans le pattern Proxy, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.10 (Façade) Identifiez les 4 principes GRASP dans le pattern Façade, selon les directives présentées à la Section 14.3.\n\n\nExercice 14.11 (Adaptateur pour Maps) Proposez une mise en œuvre du pattern GoF Adaptateur pour un système de livraison qui peut être configuré avec trois variantes du service de calcul d’itinéraires :\n\nGoogle Maps ;\nBing Maps ;\nApple Maps.\n\nLe système veut obtenir une liste d’étapes (des directions) pour se rendre à une destination à partir d’un point de départ. L’utilisateur ou l’utilisatrice du système pourra décider lequel des services lui convient dans les préférences.\nLe but de l’exercice est de déterminer l’interface stable (GRASP Protection des variations) étant donné les variantes des services de calcul d’itinéraires. Cela peut être un diagramme de classes réalisé avec PlantUML.\n\n\n\n\n\nGamma, E., Helm, R., Johnson, R., et Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software (1ʳᵉ éd.). Reading, Mass : Addison-Wesley Professional. Repéré à http://amazon.com/o/ASIN/0201633612/\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "Fiabilité.html#exercices",
    "href": "Fiabilité.html#exercices",
    "title": "15  Fiabilité",
    "section": "15.1 Exercices",
    "text": "15.1 Exercices\n\nExercice 15.1 (Faute, Erreur, Échec) Pour chaque scénario, indiquez la faute, l’erreur et l’échec (selon les définitions dans ce manuel).\nScénario 1 : Guichet automatique\nLors de son contrôle d’un guichet automatique, une technicienne constate qu’il n’y a plus de billets. Alors, elle remet des billets de 20 $ et de 50 $. La prochaine personne qui utilise ce guichet automatique indique qu’elle veut retirer 100 $, mais elle est surprise quand elle reçoit 5 billets de 50 $ (pour 250 $).\n\nFaute : \nErreur : \nÉchec : \n\nScénario 2 : Vaisseau spatial\nUne mise à jour du logiciel de contrôle sur un vaisseau spatial est effectuée par un ingénieur sur Terre. Ce nouveau programme contient une mauvaise référence pour stocker les valeurs de configuration du réacteur. Lorsque le programme effectue ce stockage, il y a une corruption du programme qui contrôle l’orientation de l’antenne pour la communication avec la Terre. Ensuite, l’antenne ne pointe plus vers la Terre, et la communication est coupée à jamais.\n\nFaute :\nErreur :\nÉchec :\n\n\n\n\n\n\nGamma, E., Helm, R., Johnson, R., et Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software (1ʳᵉ éd.). Reading, Mass : Addison-Wesley Professional. Repéré à http://amazon.com/o/ASIN/0201633612/\n\n\nHanmer, R. (2007). Patterns for Fault Tolerant Software (1ʳᵉ éd.). Chichester, England ; Hoboken, NJ : Wiley."
  },
  {
    "objectID": "DiagrammesActivites.html#diagrammes-de-flots-de-données-dfd",
    "href": "DiagrammesActivites.html#diagrammes-de-flots-de-données-dfd",
    "title": "16  Diagrammes d’activités",
    "section": "16.1 Diagrammes de flots de données (DFD)",
    "text": "16.1 Diagrammes de flots de données (DFD)\nPour la modélisation de flots de données, il existe une notation pour les diagrammes de flots de données (DFD) . Il ne s’agit pas de l’UML, mais cette notation est encore utilisée (depuis les années 1970).\nUn exemple de diagramme d’activités dans le cadre d’un cours de programmation utilisant GitHub Classroom est illustré sur la figure 16.2. Ce diagramme explique comment GitHub Classroom permet à l’étudiant ou étudiante qui accepte un devoir (assignment en anglais) sur GitHub Classroom de choisir son identité universitaire (activité en couleur rose), mais seulement si l’enseignant ou enseignante a téléversé la liste de classe (activité en couleur rose) avant d’envoyer les invitations à la communauté étudiante.\n\n\nCréerClassroomImporter liste de classe(Identifiants Moodle)CréerAssignment(Individual/Team)Partager (courriel) URL d'invitationOuvrir URLChoisir identifiant MoodleChoisir équipe (ou créer équipe)Dupliquer dépôt(au besoin, avec le compted'un(e) membre de l'organisation)Enseignant ou EnseignanteÉtudiant ou ÉtudianteGitHub\nFigure 16.2: Diagramme d’activités pour les activités séquentielles de GitHub Classroom (contexte de l’ÉTS avec Moodle)."
  },
  {
    "objectID": "DiagrammesActivites.html#exercices",
    "href": "DiagrammesActivites.html#exercices",
    "title": "16  Diagrammes d’activités",
    "section": "16.2 Exercices",
    "text": "16.2 Exercices\nCes exercices devraient vous aider à comprendre les diagrammes d’activités en UML. Vous devez vous référer au livre de Larman (2005) pour la bonne notation (chapitre F25/A28 ).\n\n\n\n\n\n\nNote\n\n\n\nVous pouvez dessiner les diagrammes à la main et en prendre une photo avec une application comme Microsoft Lens (Android, iOS).\nVous pouvez également utiliser PlantUML. Voici des ressources à ce propos : \n\ntutoriel VS Code sur YouTube \nextension PlantUML pour VS Code ;\nPlantUML Gizmo, module supplémentaire Google Docs ;\nPlantText.com.\n\nMéfiez-vous des outils comme Lucidchart ayant seulement des profils superficiels (sans règles) pour l’UML. Voir la figure 13.5 pour plus de détails.\n\n\n\nExercice 16.1 (Location de voitures) Esquissez le diagramme d’activités lors de la réception de voitures louées (après la location) dans une compagnie. Pour le diagramme, faites attention à la notation UML : cela comprend les objets (pour la voiture et pour la facture), le début et la fin de l’activité, les débranchements, les jointures, les décisions et les fusions.\n\nLes rôles sont le client, le réceptionniste (qui gère la documentation et le paiement de la location) et l’agent (qui gère le traitement des voitures avant la prochaine location).\nLe client rend la voiture et les clés au réceptionniste.\nLe réceptionniste note le kilométrage et le niveau d’essence pour calculer la facture.\nLe client paye sa location, selon le montant sur la facture.\nL’agent inspecte la voiture pour la propreté. Si elle n’est pas assez propre, alors l’agent doit laver, rincer et sécher l’extérieur et nettoyer l’intérieur. Ce travail devrait commencer le plus vite possible, après que le réceptionniste a fini de noter les informations pour la facture.\n\nVoir une solution avec PlantUML.\n\n\nExercice 16.2 (Soumission de devoir Moodle) Dessinez un diagramme d’activités qui modélise ce qui se passe lorsque vous faites un devoir dans Moodle. Votre diagramme doit comprendre les activités de l’enseignant et de l’étudiant (dans les partitions séparées). Le devoir doit être un objet dans le diagramme.\n\n\nExercice 16.3 (Soumission de devoir Google Classroom) Dessinez un diagramme d’activités qui modélise ce qui se passe lorsque vous faites un devoir dans Google Classroom. Votre diagramme doit comprendre les activités de l’enseignant et de l’étudiant (dans les partitions séparées). Le devoir doit être un objet dans le diagramme.\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "DiagrammesEtats.html#exercices",
    "href": "DiagrammesEtats.html#exercices",
    "title": "17  Diagrammes d’états",
    "section": "17.1 Exercices",
    "text": "17.1 Exercices\n\n\n\n\n\n\nNote\n\n\n\nVous pouvez dessiner les diagrammes à la main et en prendre une photo avec une application comme Microsoft Lens (Android, iOS).\nVous pouvez également utiliser PlantUML. Voici des ressources à ce propos : \n\ntutoriel VS Code sur YouTube \nextension PlantUML pour VS Code ;\nPlantUML Gizmo, module supplémentaire Google Docs ;\nPlantText.com.\n\nMéfiez-vous des outils comme Lucidchart ayant seulement des profils superficiels (sans règles) pour l’UML. Voir la figure 13.5 pour plus de détails.\n\n\n\nExercice 17.1 (États d’un téléphone) Faites un diagramme d’états en UML modélisant les états d’un téléphone intelligent. Considérez une dynamique simplifiée, avec seulement trois états correspondant aux images suivantes :\n\nPour simplifier encore le modèle : le bouton en haut à droite sert à éteindre et à allumer l’écran. Le téléphone est initialement éteint. Vous pouvez ignorer le bouton rond au centre en bas. On peut brancher l’alimentation pour charger le téléphone à tout moment, mais le bouton n’a aucun effet sur l’écran lorsque le téléphone est connecté à l’alimentation. Lorsque l’on débranche l’alimentation, l’écran est toujours éteint.\n\n\nExercice 17.2 (Guichet automatique) Faites un diagramme d’états en UML qui correspond au système décrit par les cas d’utilisation suivants (format bref) :\nS’authentifier. Le Client arrive à un guichet automatique bancaire, car il désire effectuer une transaction sur son compte. Le Client introduit sa carte bancaire, et le système attend qu’il saisisse le NIP de la carte. Si le NIP est valide pour la carte, alors le système est prêt à accepter d’autres actions. Sinon, le système enregistre la mauvaise tentative et demande de nouveau au Client de saisir son NIP. À tout moment où le système possède la carte du Client, ce dernier peut annuler la session pour récupérer sa carte.\nGérer guichet. L’Administrateur démarre le système, et le système attend l’introduction d’une carte bancaire du Client. Quand le système est dans cet état, l’Administrateur peut aussi l’éteindre.\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "ConceptionPackages.html#sec-NamespaceTypeScript",
    "href": "ConceptionPackages.html#sec-NamespaceTypeScript",
    "title": "18  Conception de packages",
    "section": "18.1 Absence de packages dans TypeScript",
    "text": "18.1 Absence de packages dans TypeScript\nEn effet, TypeScript n’a pas la notion de package comme dans C# ou Java. Cependant, il y a des pratiques pour organiser logiquement le code et pour éviter les conflits (les collisions) de noms. Rappelons que la notion de package existe dans Java pour :\n\nOrganiser logiquement le code : le type interface java.util.List est disponible dans la bibliothèque java.util) ;\nÉviter les conflits de noms : les classes java.util.List et ca.etsmtl.log121.fuhrman.projet2.List ont le même nom de base, mais puisqu’elles sont dans deux packages différents, elles peuvent être utilisées dans le même programme (leur « fully qualified name » est différent).\n\nEn TypeScript, on peut atteindre les mêmes objectifs.\n\n18.1.1 Organisation des éléments du code\nL’organisation peut être réalisée grâce aux modules avec les mots-clés export et import. Par exemple :\n// maClasse.ts\nexport class MaClasse {\n  // définition\n}\n// client.ts\nimport { MaClasse } from './maClasse'\nOn organise les fichiers, par exemple maClasse.ts, dans les répertoires.\n\n\n18.1.2 Noms sans conflit\nDans l’exemple précédent, il ne serait pas possible d’avoir deux fichiers nommés maClasse.ts dans le même répertoire, alors il est impossible d’avoir une collision avec le nom du fichier. Donc, on pourrait importer la classe MaClasse de maClasse.ts et la classe MaClasse de lib/projet2/maClasse.ts dans le même programme. Cependant, pour éviter un conflit de noms, on emploie le mot-clé as pour renommer la classe (MaClasseP2) lorsqu’on l’importe :\n// client.ts\nimport { MaClasse } from './maClasse'\nimport { MaClasse as MaClasseP2 } from './lib/projet2/maClasse'\n\n\n18.1.3 Namespaces\nTypeScript offre une autre manière pour organiser et éviter les conflits de noms avec les namespaces (anciennement les modules internes). L’exemple de Validators est intéressant puisqu’il s’agit d’un namespace commun réparti dans plusieurs fichiers. C’est à utiliser surtout lorsqu’on ne veut pas centraliser tout le code dans un seul (gros) fichier (avec export). Mais, comme vous le voyez dans l’exemple, on doit utiliser les commentaires dans le code de certains fichiers, par exemple\n/// <reference path=\"Validation.ts\" />, et c’est plus compliqué à maintenir."
  },
  {
    "objectID": "DiagrammesDeploiement.html#diagrammes-de-déploiement",
    "href": "DiagrammesDeploiement.html#diagrammes-de-déploiement",
    "title": "19  Diagrammes de déploiement et de composants",
    "section": "19.1 Diagrammes de déploiement",
    "text": "19.1 Diagrammes de déploiement\nUn diagramme de déploiement présente le déploiement sur l’architecture physique. Il sert à documenter :\n\ncomment les fichiers exécutables seront affectés sur les nœuds de traitement, et\nla communication entre composants physiques.\n\nVoici les éléments importants :\n\nTypes de nœuds :\n\nNœud physique (équipement) : Ressource de traitement physique (par exemple, de l’électronique numérique) dotée de services de traitement et de mémoire destinés à exécuter un logiciel. Ordinateur classique, cellulaire, etc.\nNœud d’environnement d’exécution (EEN, execution environment node) : Ressource de traitement logiciel qui s’exécute au sein d’un nœud externe (comme un ordinateur) et offrant elle-même un service pour héberger et exécuter d’autres logiciels, par exemple :\n\nun système d’exploitation (OS) est un logiciel qui héberge et qui exécute des programmes ;\nune machine virtuelle (JVM ou .NET) ;\nun moteur de base de données (par exemple PostgreSQL) exécute les requêtes SQL ;\nun navigateur Web qui héberge et qui exécute JavaScript ;\nun moteur de workflow ;\nun conteneur de servlets ou conteneur Docker.\n\n\n\nLa figure 19.1 est un exemple de diagramme de déploiement (laboratoire). La figure 19.2 est un exemple de diagramme de déploiement pour le logiciel iTunes d’Apple.\n\n\nNavigateur moderne« Système »Système de gestiondes apprentissages(SGA)« Système »Système de gestiondes bordereaux(SGB)Application frontaleminimaliste, par exempleles pages Web etun peu de JavaScriptRoutageApplication conçueselon la méthodologieproposée par LarmanSolutionsimpleSource pour lesinfos sur les cours,les étudiant(e)s, etc.Destination pour lesrésultats des question-naires et des devoirs.NœudphysiqueNœudd'environnementd'exécutionAPI REST niveau 1API REST\nFigure 19.1: Diagramme de déploiement du système à développer pour le laboratoire.\n\n\n\n\n« device »Apple Web Server« website »iTunes« website »iTunes Store« device »Home Computer« mobile device »iPhone/iPad/etc.« application »iTunesSetup.exeMedia Library« web browser »« application »iTunesMedia Library« OS »iOSMedia LibraryLes médiathèques sontsynchronisées entreles appareils par iTunes.USB« protocol »iTunes Store Protocol« protocol »HTTP« wireless protocol »iTunes Store Protocol\nFigure 19.2: Diagramme de déploiement pour iTunes d’Apple avec un ordinateur, un iPad et le service Web d’Apple, selon ce modèle UML de Kirill Fakhroutdinov (utilisé avec permission)."
  },
  {
    "objectID": "Laboratoires.html#typescript",
    "href": "Laboratoires.html#typescript",
    "title": "20  Laboratoires",
    "section": "20.1 TypeScript",
    "text": "20.1 TypeScript\nQu’est-ce que TypeScript ? Selon Goldberg (2022), TypeScript comprend quatre éléments :\n\nUn langage de programmation ayant toute la syntaxe de JavaScript, plus une syntaxe propre à TypeScript pour définir et utiliser les types ;\nUn vérificateur de type pouvant décortiquer un ensemble de fichiers en JavaScript et en TypeScript définissant des variables, des fonctions, etc., afin d’indiquer d’éventuels problèmes de configuration ;\nUn compilateur qui\n\ninvoque le vérificateur de type,\nsignale des problèmes si nécessaire et\nfinalement génère du code en JavaScript équivalent ;\n\nUn service de langage qui transmet des informations provenant du vérificateur de type à l’IDE pour que ce dernier puisse faciliter le développement."
  },
  {
    "objectID": "Laboratoires.html#javascripttypescript",
    "href": "Laboratoires.html#javascripttypescript",
    "title": "20  Laboratoires",
    "section": "20.2 JavaScript/TypeScript",
    "text": "20.2 JavaScript/TypeScript\nPour la personne ayant déjà des connaissances de Java et des patterns GoF, Gamma, Helm, Johnson, et Vlissides (1994), il est recommandé d’apprendre les choses dans cet ordre :\n\nJavaScript : un tutoriel intéressant (et libre) se trouve sur fr.javascript.info. Nous vous recommandons de contribuer à des traductions en français sur GitHub.\nTypeScript : ce tutoriel est en anglais, mais il est adapté à des personnes ayant déjà une expérience en Java/C#.\n\nVoici des points importants pour le projet de laboratoire, organisés pour quelqu’un ayant déjà des connaissances en Java :\n\nTypeScript se traduit (« emits ») en JavaScript, alors il faut comprendre le moteur d’exécution JavaScript.\nPour convertir une chaîne en nombre, pour lire ou écrire un fichier sur disque, etc., on utilise des opérations en JavaScript.\nUn type en TypeScript est comme un ensemble de valeurs plutôt qu’une définition hiérarchique. En Java, il n’est pas possible d’avoir un type pouvant être soit une chaîne soit un nombre. Mais, en TypeScript, c’est facile de déclarer un type comme une union de plusieurs types, par exemple string | number.\nJavaScript a des notions de « truthy » et « falsy » (conversion d’une expression en une valeur booléenne) permettant de vérifier avec moins de code si une variable est définie ou initialisée, etc.\nL’opérateur d’égalité stricte (===) (sans conversion de type).\nLes fonctions fléchées (fat arrow functions en anglais).\nLe traitement asynchrone en JavaScript :\n\nPromesses et async/await.\n\nLes services REST (GET vs PUT).\nEnvironnement de test (Jest).\nLes gabarits (templates) Pug (anciennement Jade) : Tutoriel (court) , Tutoriel (plus complet) .\nBootstrap (mise en page avec CSS) : Tutoriel (attention, il faut appliquer les éléments dans les gabarits Pug) .\n\nLe lab 0 aborde plusieurs de ces aspects, mais certaines notions sont plus complexes et nécessitent une étude approfondie. Le but de cette section est de donner des tutoriels plus spécifiques. Enseigner la syntaxe ou les principes du langage TypeScript n’est pas le but de ce manuel, mais apprendre à trouver l’information soi-même est essentiel pour une personne travaillant dans les technologies de l’information.\nIl y a un dépôt d’exemples avec TypeScript (utilisant ts-node pour les voir facilement) sur GitHub. Il y a un exemple qui montre comment faire des REST à partir de TypeScript avec le système SGB."
  },
  {
    "objectID": "Laboratoires.html#javascript-truthy-et-falsy-conversion-en-valeur-booléenne",
    "href": "Laboratoires.html#javascript-truthy-et-falsy-conversion-en-valeur-booléenne",
    "title": "20  Laboratoires",
    "section": "20.3 JavaScript : Truthy et Falsy (conversion en valeur booléenne)",
    "text": "20.3 JavaScript : Truthy et Falsy (conversion en valeur booléenne)\nJavaScript offre un mécanisme simple pour vérifier des valeurs dans une expression if. Imaginez l’exemple suivant :\nlet maVariable;\n\n// d'autres instructions...\n\nif (maVariable != undefined \n    && maVariable != null \n    && maVariable != '') {\n  // on peut faire quelque chose avec maVariable...\n}\nOn vérifie trois possibilités pour maVariable avant de l’utiliser. Ce genre de situation arrive souvent en JavaScript, puisque les objets peuvent prendre des valeurs différentes selon le contexte. Contrairement à Java, les types des variables JavaScript peuvent changer dynamiquement. Il serait bien de pouvoir réduire la quantité de code dans ces cas.\nGrâce à la notion de conversion de valeur selon la règle de « truthy » et « falsy », JavaScript permet de simplifier les instructions en une seule condition, sans ET (&&), en convertissant la valeur de maVariable en booléenne true ou false :\n// conversion booléenne selon la règle de « truthy » et « falsy »\nif (maVariable) {\n  // on peut faire quelque chose avec maVariable...\n}\nIl faut comprendre la règle de conversion en valeur booléenne selon « truthy » et « falsy ». En fait, il est plus simple de commencer par les valeurs se traduisant en false (« falsy »), car tout ce qui ne l’est pas est donc true (« truthy »).\n\n20.3.1 Falsy\nLes valeurs suivantes se convertissent en false dans une condition :\n\nfalse\nnull\nundefined\n0 (attention, c’est parfois un piège)\nNaN (not a number)\n'' ou \"\" (chaîne vide)\n\n\n\n20.3.2 Truthy\nTout ce qui n’est pas converti en false (expliqué ci-dessus) est converti en true. En voici quelques exemples :\n\n{} (objet vide)\n[] (tableau vide)\n-20\netc.\n\n\n\n\n\n\n\nMise en garde\n\n\n\nN’oubliez pas que la valeur de 0 est « falsy » dans une condition. C’est souvent un piège en JavaScript quand on considère les variables qui peuvent avoir une valeur numérique. Par exemple, si l’on fait if (maVariable) pour tester si une variable est définie, si la variable est définie et que sa valeur est 0, la condition sera false."
  },
  {
    "objectID": "Laboratoires.html#git",
    "href": "Laboratoires.html#git",
    "title": "20  Laboratoires",
    "section": "20.4 Git",
    "text": "20.4 Git\nGit est un logiciel de gestion des versions permettant de stocker un ensemble de fichiers en conservant la chronologie de tous les changements ayant été effectués dessus. Ce genre de logiciel permet de retrouver les différentes versions d’un lot de fichiers connexes. Depuis 2010, Git est le logiciel de gestion des versions le plus populaire, disponible sur les environnements Windows, Mac et Linux. Il s’agit d’un logiciel libre et gratuit, créé en 2005 par Linus Torvalds, fondateur du noyau Linux. Linus Torvalds prononce Git avec un g dur (Google, 2007).\nGit est particulier parce qu’il est décentralisé, utilisant un système de connexion pair à pair. Les fichiers informatiques sont stockés sur l’ordinateur de chaque personne qui contribue au projet et ils peuvent également l’être sur un serveur dédié comme GitHub, GitLab, Bitbucket, etc.\nPuisque chaque personne est libre de modifier les fichiers comme elle le veut, sans être bloquée par les autres contributeurs et contributrices, il est nécessaire de synchroniser et de fusionner les contributions de temps en temps. Cette synchronisation peut être plus ou moins compliquée, selon les travaux réalisés par chaque personne, par exemple lorsque deux entre elles ont modifié un même fichier sur leur ordinateur. Une des forces de Git est l’ensemble des fonctionnalités permettant de gérer tous les cas de synchronisation. Mais cet avantage peut aussi faire en sorte que Git soit compliqué à utiliser. La figure 20.1 présente un survol des concepts et des opérations de base de Git.\nCe manuel ne rentre pas dans les détails de chaque opération Git ; il existe plusieurs tutoriels pour Git sur Internet. Il y a beaucoup de scénarios où Git peut être utile, par exemple pour récupérer une version antérieure d’un fichier ou pour savoir qui a apporté une modification à un fichier, etc. Apprendre tous les cas d’utilisation de Git serait long et inintéressant. Il n’est pas nécessaire de tout comprendre pour commencer.\n\n\n\nFigure 20.1: Concepts et opérations de base de Git. « Basic Git Concepts and Operations » de Costa Shulyupin, utilisé sous EPL."
  },
  {
    "objectID": "Laboratoires.html#sec-ContributionsEquipe",
    "href": "Laboratoires.html#sec-ContributionsEquipe",
    "title": "20  Laboratoires",
    "section": "20.5 Évaluer les contributions des membres de l’équipe",
    "text": "20.5 Évaluer les contributions des membres de l’équipe\nIl existe un outil nommé gitinspector qui peut indiquer le niveau d’implication des membres de l’équipe dans un projet sur GitHub. Étant donné que les laboratoires de ce manuel utilisent un squelette avec les tests, les fichiers src de TypeScript, les modèles PlantUML et le README.md, il est possible d’utiliser gitinspector pour voir des rapports de contribution sur chacun des volets.\nPour faciliter l’utilisation de l’outil, le professeur Fuhrman a créé un script en bash. Voici comment l’utiliser :\n\nInstaller gitinspector dans npm avec la commande npm install -g gitinspector ;\nTélécharger le script :\n\ngit clone \\\nhttps://gist.github.com/fuhrmanator/b5b098470e7ec4536c35ca1ce3592853 \\\ncontributions\nCloning into 'contributions'...\nremote: Enumerating objects: 10, done.\nremote: Counting objects: 100% (10/10), done.\nremote: Compressing objects: 100% (5/5), done.\nremote: Total 10 (delta 3), reused 7 (delta 2), pack-reused 0\nUnpacking objects: 100% (10/10), 2.02 KiB | 82.00 KiB/s, done.\n\nLancer le script sur un dépôt de code source, par exemple sga-equipe-g02-equipe-4 :\n\ncd contributions\n./contributions.sh ../sga-equipe-g02-equipe-4/\ngitinspector running on ../sga-equipe-g02-equipe-4/: patience...\nContributionsÉquipeTest.html\nContributionsÉquipeModèles.html\nContributionsÉquipeDocs.html\nContributionsÉquipeTypeScript.html\nContributionsÉquipeViews.html\nLes fichiers .html sont créés pour les contributions Test, Modèles, Docs, TypeScript et Views. Chaque rapport indique les contributions selon deux perspectives :\n\nLe nombre de soumissions par auteur ou auteure (activité Git) ;\nLe nombre de lignes par auteur ou auteure encore présentes et intactes dans la version HEAD.\n\nVous pouvez voir un exemple de rapport à la figure 20.2.\n\n\n\nFigure 20.2: Exemple de rapport généré par gitinspector.\n\n\n\n20.5.1 Faire le bilan de la contribution de chaque membre\nAprès l’évaluation à la fin de chaque itération, il est important de quantifier et de considérer la contribution de chacun et chacune au projet et de valider avec les responsabilités prévues dans le plan de l’itération. Il est normal d’avoir un écart entre le travail prévu et le travail effectué. Un des objectifs du bilan est d’essayer d’expliquer les gros écarts et de corriger ou mitiger les problèmes.\nPar exemple, on peut voir sur la figure 20.2 qu’Anne et Justin ont fait une contribution beaucoup plus importante que Francis et Mélanie. Dans le bilan de l’itération, on doit indiquer explicitement ce fait, même avec des pourcentages.\n\n\n\n\n\n\nImportant\n\n\n\nUne phrase vague comme « des membres ont travaillé plus que d’autres » est une formulation diplomatique, mais elle n’est pas assez explicite et n’est pas une résolution proactive du problème, si nécessaire.\n\n\n\n\n20.5.2 Proposer des solutions au besoin\nUne inégalité importante dans les contributions est un signal d’alarme. On doit agir, mais on commence par poser des questions, par exemple :\n\nEst-ce que Francis et Mélanie sont à l’aise avec les technologies utilisées dans le lab ? Ont-ils besoin de coaching ?\nSont-ils des « parasites » ou des « mollassons » (Oakley, Felder, Brent, et Elhajj, 2004) (traduction française de l’article) ? À certaines universités, le plan de cours vous permet d’exclure leurs noms du rapport (et ils auront une note de zéro pour la remise), mais seulement s’ils n’ont rien fait du tout (ce qui n’est pas le cas dans l’exemple ci-dessus). Une personne exclue de cette manière va probablement abandonner le cours, et vous perdrez définitivement un ou une membre de l’équipe.\nEst-ce qu’Anne et Justin ont laissé suffisamment de liberté aux autres pour faire une contribution importante ? Font-ils assez confiance aux autres ?\nAvez-vous fait un plan d’itération assez détaillé pour que chaque membre puisse contribuer adéquatement ? Dans l’exemple ci-dessus, peut-être Francis et Mélanie ont-ils trouvé ça difficile de savoir où contribuer ?\nEst-ce que tout le monde assiste aux séances de laboratoire ?\nEst-ce que tout le monde travaille au moins 6 heures en dehors des séances encadrées ?\nEst-ce que certaines personnes travaillent excessivement, sans donner la chance aux autres de contribuer ? N’oubliez pas que les laboratoires sont une manière d’apprendre à pratiquer la matière de ce manuel. Laisser un ou deux membres de l’équipe faire plus de travail peut nuire à la valeur pédagogique des laboratoires (ça peut faire mal à l’examen final pour les membres qui ont moins contribué). Il y a aussi un risque sur le plan de la Redondance des compétences dans l’équipe (bus factor), surtout si une personne qui travaille beaucoup plus que les autres éprouve un problème d’épuisement à cause du fait qu’elle travaille trop.\nEst-ce que tout le monde utilise un moyen de communication de manière synchrone et asynchrone (Slack, Discord, Teams, etc.) ? Le courriel n’est pas l’outil idéal pour coordonner un travail en équipe.\nEtc.\n\nDans le bilan, il faut constater les faits et proposer des solutions pour éviter des inégalités importantes sur le plan de la contribution dans les prochaines itérations. Ainsi, vous gérerez les problèmes de manière plus proactive.\n\n\n20.5.3 FAQ pour gitinspector\nQ : Comment fusionner le travail réalisé par une même personne, mais avec plusieurs comptes (courriels) différents ?\nR : La solution est avec le fichier .mailmap. Vous pouvez rapidement générer un fichier de base avec la commande :\ngit shortlog -se | sed \"s/^.*\\\\t//\"  > .mailmap\nEnsuite, modifiez le fichier .mailmap pour respecter ce format :\nPrénom Nom Désirés <courriel> Prénom Nom Non Désirés <courriel>\nPar exemple, le .mailmap initial qui contient quatre entrées pour le même auteur :\nC. Fuhrman <christopher.fuhrman@etsmtl.ca>\nChristopher (Cris) Fuhrman <christopher.fuhrman@etsmtl.ca>\nChristopher Fuhrman <christopher.fuhrman@etsmtl.ca>\nCris Fuhrman <fuhrmanator+git@gmail.com>\nOn décide de garder l’alias C. Fuhrman <christopher.fuhrman@etsmtl.ca> pour chaque nom :\nC. Fuhrman <christopher.fuhrman@etsmtl.ca>\nC. Fuhrman <christopher.fuhrman@etsmtl.ca> Christopher (Cris) Fuhrman <christopher.fuhrman@etsmtl.ca>\nC. Fuhrman <christopher.fuhrman@etsmtl.ca> Christopher Fuhrman <christopher.fuhrman@etsmtl.ca>\nC. Fuhrman <christopher.fuhrman@etsmtl.ca> Cris Fuhrman <fuhrmanator+git@gmail.com>\nLe nom que vous mettez sera celui qui apparaît dans les rapports la prochaine fois qu’ils seront générés.\nQ : Comment exclure le travail réalisé par un(e) chargé(e) de laboratoire (par exemple le clone initial dans GitHub Classroom) ?\nR : La solution est d’ajouter le nom de l’auteur ou de l’auteure dans le tableau du script contributions.sh à la ligne suivante avec authorsToExcludeArray. Attention :\n\nIl n’y a pas de , entre les éléments des tableaux en bash.\nUn nom contenant un accent ne sera pas reconnu. Il faut changer le nom dans le .mailmap pour qu’il n’y ait pas d’accents, ou utiliser une chaîne partielle comme \"Benjamin Le\" pour exclure les contributions de \"Benjamin Le Dû\".\n\nauthorsToExcludeArray=(\"C. Fuhrman\" \"Benjamin Le\" \"Yvan Ross\")\nQ : J’ai une autre question…\nR : Il y a aussi une FAQ sur le dépôt de gitinspector.\n\n\n\n\nGamma, E., Helm, R., Johnson, R., et Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software (1ʳᵉ éd.). Reading, Mass : Addison-Wesley Professional. Repéré à http://amazon.com/o/ASIN/0201633612/\n\n\nGoldberg, J. (2022). Learning TypeScript: Enhance Your Web Development Skills Using Type-Safe JavaScript (1st edition). (S.l.) : O’Reilly Media.\n\n\nGoogle. (2007, 14 mai). Tech Talk: Linus Torvalds on git. Repéré à https://www.youtube.com/watch?v=4XpnKHJAok8\n\n\nOakley, B., Felder, R., Brent, R., et Elhajj, I. (2004). Coping with Hitchhikers and Couch Potatoes on Teams. Journal of Student Centered Learning, 2(1), 32‑34. Repéré à https://www.cs.cornell.edu/courses/cs3110/2018fa/teams/hitchhikers.html"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Ardis, M., Hislop, G., Sebern, M., Budgen, D., Offutt, J., et Visser, W.\n(2015). Software Engineering 2014 - Curriculum\nGuidelines for Undergraduate Degree Programs in\nSoftware Engineering. ACM: Association for\nComputing Machinery.\n\n\nAvgeriou, P., Kruchten, P., Ozkaya, I., et Seaman, C. (2016).\nManaging Technical Debt in Software Engineering (Dagstuhl Seminar\n16162). Dagstuhl Reports, 6(4), 110‑138. https://doi.org/10.4230/DagRep.6.4.110\n\n\nBlincoe, K., Dehghan, A., Salaou, A.-D., Neal, A., Linaker, J., et\nDamian, D. (2019). High-level software requirements and iteration\nchanges: a predictive model. Empirical Software Engineering,\n24(3), 1610‑1648.\n\n\nBoittiaux, P. (2016, 13 décembre). Infographie: Le Web dit adieu à\nFlash. Statista Infographies. Repéré à https://fr.statista.com/infographie/7186/le-web-dit-adieu-a-flash/\n\n\nChen, O., Kalyuga, S., et Sweller, J. (2017). The expertise reversal\neffect is a variant of the more general element interactivity effect.\nEducational Psychology Review, 29(2), 393‑405.\n\n\nCoad, P. (1997). Object Models:\nStrategies, Patterns, and\nApplications (2ᵉ éd.). Upper Saddle River,\nN.J : Pearson Technology Group.\n\n\nCunningham, W. (1992). The WyCash portfolio management system. Dans\nConference on Object-Oriented Programming Systems, Languages, and\nApplications.\n\n\nFitzpatrick, B. W., et Collins-Sussman, B. (2012). Team\nGeek: A Software\nDeveloper’s Guide to Working\nWell with Others (1ʳᵉ éd.). Sebastopol.\nCA : O’Reilly Media.\n\n\nFord, N. (2009, 24 février). Evolutionary architecture and emergent\ndesign: Investigating architecture and design. [{CT}316].\nRepéré à https://web.archive.org/web/20161029141308/http://www.ibm.com/developerworks/library/j-eaed1/\n\n\nFowler, M. (2007, juin). Bliki: DesignStaminaHypothesis.\nmartinfowler.com. Repéré à https://www.martinfowler.com/bliki/DesignStaminaHypothesis.html\n\n\nFowler, M. (2018). Refactoring: Improving the Design of Existing\nCode (2ᵉ éd.). Boston : Addison-Wesley Professional.\n\n\nGamma, E., Helm, R., Johnson, R., et Vlissides, J. (1994). Design\nPatterns: Elements of Reusable\nObject-Oriented Software\n(1ʳᵉ éd.). Reading, Mass : Addison-Wesley Professional. Repéré à http://amazon.com/o/ASIN/0201633612/\n\n\nGoldberg, J. (2022). Learning TypeScript: Enhance\nYour Web Development Skills Using Type-Safe JavaScript (1st\nedition). (S.l.) : O’Reilly Media.\n\n\nGoogle. (2007, 14 mai). Tech Talk: Linus Torvalds on git.\nRepéré à https://www.youtube.com/watch?v=4XpnKHJAok8\n\n\nHanmer, R. (2007). Patterns for Fault\nTolerant Software (1ʳᵉ éd.). Chichester,\nEngland ; Hoboken, NJ : Wiley.\n\n\nKarac, I., et Turhan, B. (2018). What Do We (Really) Know about\nTest-Driven Development? IEEE Software, 35(4), 81‑85.\nhttps://doi.org/10.1109/MS.2018.2801554\n\n\nLarman, C. (2001). Applying UML and\nPatterns: An Introduction to\nObject-Oriented Analysis and Design and the\nUnified Process (2nd edition). Upper Saddle\nRiver, NJ : Prentice Hall.\n\n\nLarman, C. (2005). UML 2 et les design patterns\n(3ᵉ éd.). Paris : Village Mondial.\n\n\nLaTeX. (2022). Dans Wikipedia. Repéré à https://en.wikipedia.org/w/index.php?title=LaTeX&oldid=1114993597\n\n\nOakley, B., Felder, R. M., Brent, R., et Elhajj, I. (2004a). Turning\nstudent groups into effective teams. Journal of student centered\nlearning, 2(1), 9‑34.\n\n\nOakley, B., Felder, R., Brent, R., et Elhajj, I. (2004b). Coping with\nHitchhikers and Couch Potatoes on Teams. Journal of Student Centered\nLearning, 2(1), 32‑34. Repéré à https://www.cs.cornell.edu/courses/cs3110/2018fa/teams/hitchhikers.html\n\n\nOakley, B., et Sejnowski, T. J. (2021). Uncommon sense teaching:\nPractical insights in brain science to help students learn.\n(S.l.) : Penguin.\n\n\nPandoc. (2022). Dans Wikipedia. Repéré à https://en.wikipedia.org/w/index.php?title=Pandoc&oldid=1116852485\n\n\nPlantUML. (2022). Dans Wikipedia. Repéré à https://en.wikipedia.org/w/index.php?title=PlantUML&oldid=1111009429\n\n\nQuarto. (2023, 14 février). Repéré à https://quarto.org/"
  },
  {
    "objectID": "Annexe_Cas_utilisation_Réserver_livre.html",
    "href": "Annexe_Cas_utilisation_Réserver_livre.html",
    "title": "Appendix A — Cas d’utilisation – Réserver un livre de la bibliothèque",
    "section": "",
    "text": "Parties prenantes et intérêts :\n\nLa personne membre. Elle veut un moyen de recherche exact et rapide, et ne veut pas que la Bibliothèque mémorise des informations sur ses recherches (confidentialité). Elle veut pouvoir réaliser des réservations aisément et obtenir un service rapide en fournissant un minimum d’efforts. Elle veut également une preuve de réservation.\n\nLa Bibliothèque. Elle veut enregistrer correctement les réservations et satisfaire les souhaits des membres.\n\nPréconditions : La personne membre est identifiée et authentifiée.\nActeur principal : Personne membre\n\nLa personne membre choisit la fonction « recherche » et saisit du texte décrivant le livre (par exemple une partie du titre, « UML »).\nLe système affiche une liste de livres (le titre, l’auteur ou l’auteure et l’année) correspondant à la recherche, par exemple « UML 2 et les design patterns, Craig Larman, 2005 » et « UML par la pratique, Pascal Roques, 2009 ».\nLa personne membre choisit un livre parmi les résultats, par exemple « UML 2 et les designs patterns, Craig Larman, 2005 ».\nLe système affiche les informations détaillées du livre (le titre, l’auteur ou l’auteure, le numéro ISBN, la maison d’édition, le numéro de l’édition et l’année) ainsi que la liste de tous les exemplaires du livre indiquant s’ils sont disponibles ou pas, par exemple deux exemplaires du livre « UML 2 et les design patterns », un avec l’identificateur d’exemplaire « 1 » qui est disponible et un avec l’identificateur d’exemplaire « 2 » qui n’est pas disponible.\nLa personne membre réserve un exemplaire du livre qui est disponible.\nLe système confirme la réservation en affichant un numéro de réservation avec le nom de la personne membre et le code de l’exemplaire du livre.\n\nExtensions (scénarios alternatifs) :\n\nAucun livre ne correspond au texte de la recherche.\n\nLe système affiche un message indiquant qu’aucun livre n’a été trouvé.\nLa personne membre lance une nouvelle recherche.\n\n\n\n\nTous les exemplaires sont indisponibles.\n\nLe système affiche toutes les informations du livre et des exemplaires, mais un message indique qu’il n’est pas possible de réserver, faute d’exemplaires disponibles.\nLa personne membre lance une nouvelle recherche."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Traiter_vente.html#sec-DSS_traiter_vente",
    "href": "Annexe_Cas_utilisation_Traiter_vente.html#sec-DSS_traiter_vente",
    "title": "Appendix B — Cas d’utilisation – Traiter une vente",
    "section": "B.1 DSS",
    "text": "B.1 DSS\n\n\nTraiter une vente:Caissier:SystèmedémarrerVenteloop[reste des articles]saisirArticle(codeArticle : int, quantité : int)description, totalterminerVente()total avec taxescréerPaiement(montant : Monnaie)remise de la monnaie, du reçu\nDSS pour le scénario Traiter une vente de Larman (2005)."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Traiter_vente.html#mdd-partiel",
    "href": "Annexe_Cas_utilisation_Traiter_vente.html#mdd-partiel",
    "title": "Appendix B — Cas d’utilisation – Traiter une vente",
    "section": "B.2 MDD partiel",
    "text": "B.2 MDD partiel\n\n\nLigneArticlequantité : intVentedateHeure : DateHeureestTerminée : booleanPaiementmontant : MonnaieMagasinnom : Stringadresse : StringDescriptionProduitdescription : Stringprix : MoneycodeArticle : intCatalogueProduitRegistreContient1..*1Héberge1..*1Saisie-sur11Payée-par111*Décrite-par*1\nMDD pour le scénario Traiter une vente de Larman (2005).\n\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Ouvrir_caisse.html#terminologie",
    "href": "Annexe_Cas_utilisation_Ouvrir_caisse.html#terminologie",
    "title": "Appendix C — Cas d’utilisation – Ouvrir la caisse",
    "section": "C.1 Terminologie",
    "text": "C.1 Terminologie\nQuelques termes du domaine d’affaires doivent être compris avant de procéder :\n\nTiroir-caisse.\n\nC’est la partie de la caisse qui s’ouvre, dans laquelle on peut placer un plateau-billets.\n\nPlateau-billets.\n\nC’est un contenant pour les billets de banque et les pièces de monnaie qui facilite le changement de personnel à une caisse. Chaque caissier ou caissière possède un plateau-billets et l’apporte au début ou à la fin de son quart de travail."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Ouvrir_caisse.html#cas-dutilisation-ouvrir-la-caisse",
    "href": "Annexe_Cas_utilisation_Ouvrir_caisse.html#cas-dutilisation-ouvrir-la-caisse",
    "title": "Appendix C — Cas d’utilisation – Ouvrir la caisse",
    "section": "C.2 Cas d’utilisation : Ouvrir la caisse",
    "text": "C.2 Cas d’utilisation : Ouvrir la caisse\nActeur principal : Caissier ou Caissière\nPréconditions : La caisse est libre et son tiroir-caisse est vide (il n’y a pas de plateau dedans).\nGaranties de succès (postconditions) : La caissière ou le caissier est authentifié. Son plateau-billets est placé dans le tiroir-caisse, et son identificateur est enregistré. Le montant d’argent du plateau est enregistré. L’heure de l’arrivée du caissier ou de la caissière est enregistrée.\nScénario principal (succès)\n\nLe Caissier ou la Caissière arrive à la caisse avec son plateau-billets.\nLe Caissier ou la Caissière saisit son identifiant et son mot de passe dans la boîte de dialogue d’authentification.\nLe Système authentifie le Caissier ou la Caissière.\nLe Système ouvre le tiroir-caisse et demande au Caissier ou à la Caissière de poser son plateau dans le tiroir-caisse.\nLe Caissier ou la Caissière pose son plateau dans le tiroir-caisse.\nLe Système reconnaît l’identificateur du plateau.\nLe Système demande au Caissier ou à la Caissière de saisir le montant d’argent du plateau.\nLe Caissier ou la Caissière saisit le montant d’argent du plateau.\nLe Système demande au Caissier ou à la Caissière de fermer le tiroir-caisse.\nLe Caissier ou la Caissière ferme le tiroir-caisse.\n\nSpécifications particulières :\nLes caisses sont configurées avec un modèle de plateau-billets comme celui-ci : voir exemple sur YouTube .\nFréquence d’occurrence : Normalement, au début du quart de travail de chaque caissier ou caissière."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Ouvrir_caisse.html#modèle-du-domaine-partiel",
    "href": "Annexe_Cas_utilisation_Ouvrir_caisse.html#modèle-du-domaine-partiel",
    "title": "Appendix C — Cas d’utilisation – Ouvrir la caisse",
    "section": "C.3 Modèle du domaine partiel",
    "text": "C.3 Modèle du domaine partiel\nVoici un exemple pour le système NextGen POS. Notez les nouvelles classes conceptuelles PlateauBillets (un objet physique) et MisePlateau (une transaction) faisant partie du scénario d’Ouvrir la caisse.\n\n\n\nModèle du domaine partiel pour le système NextGen POS présentant les différences par rapport au modèle du domaine de base présenté par Larman, avec l’ajout des classes conceptuelles PlateauBillets et MisePlateau, qui modélisent de nouveaux éléments du cas d’utilisation Ouvrir la caisse.\n\n\nOn remarque que lorsqu’un Registre (Caisse) n’a pas de Caissier (l’état du système au début du cas d’utilisation), l’objet Registre n’est associé à aucun objet Caissier. Nous avons donc modifié les cardinalités de l’association en conséquence. C’est une différence par rapport au modèle du domaine de base présenté par Larman, qui n’avait pas considéré ce cas d’utilisation, bien qu’il soit dans l’ensemble des spécifications du système.\nLes associations en rouge sont celles qui sont affectées par la dynamique de ce cas d’utilisation."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Ouvrir_caisse.html#diagramme-de-séquence-système-dss",
    "href": "Annexe_Cas_utilisation_Ouvrir_caisse.html#diagramme-de-séquence-système-dss",
    "title": "Appendix C — Cas d’utilisation – Ouvrir la caisse",
    "section": "C.4 Diagramme de séquence système (DSS)",
    "text": "C.4 Diagramme de séquence système (DSS)\nLa figure C.2 est le diagramme de séquence système (DSS) pour le scénario Ouvrir la caisse.\n\n\nOuvrir la caisse:Caissier:SystèmedémarrerOuvrirCaisse()authentifier(identifiant : String, mdp : String)confirmation, ouverture du tiroirposerPlateau(identifiant : String)saisirMontant(montant : Monnaie)fermerTiroir()\nFigure C.2: Diagramme de séquence système (DSS) pour le scénario Ouvrir la caisse."
  },
  {
    "objectID": "Annexe_Cas_utilisation_Ouvrir_caisse.html#contrats-dopération",
    "href": "Annexe_Cas_utilisation_Ouvrir_caisse.html#contrats-dopération",
    "title": "Appendix C — Cas d’utilisation – Ouvrir la caisse",
    "section": "C.5 Contrats d’opération",
    "text": "C.5 Contrats d’opération\nVoici les contrats pour chaque opération système.\nOpération : démarrerOuvrirCaisse()\nPostconditions :\n\nUne instance mp de MisePlateau a été créée.\n\nOpération : authentifier(identifiant : String, mdp : String)\nPostconditions :\n\nmp a été associée à un Caissier, sur la base de correspondance avec identifiant.\nLe Registre en cours a été associé à un Caissier, sur la base de correspondance avec identifiant.\n\nOpération : poserPlateau(identifiant : String)\nPostconditions :\n\nmp a été associée à un PlateauBillets, sur la base de correspondance avec identifiant.\nLe Registre en cours a été associé à un PlateauBillets, sur la base de correspondance avec identifiant.\n\nOpération : saisirMontant(montant : Monnaie)\nPostcondition :\n\nmp.montant est devenu montant.\n\nOpération : fermerTiroir()\nPostconditions :\n\nmp.dateHeure est devenue la date et l’heure actuelles.\nmp a été associée à GrandLivre.\nmp a été associée à Registre.\n\n\n\n\n\nLarman, C. (2005). UML 2 et les design patterns (3ᵉ éd.). Paris : Village Mondial."
  }
]