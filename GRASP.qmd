# Principes GRASP

GRASP est un acronyme de l'expression anglaise "General Responsibility Assignment Software Patterns", c'est-à-dire les principes pour affecter les responsabilités logicielles dans les classes.

Une approche GRASP devrait amener un design vers la modularité et la maintenabilité.

L'acronyme d'une expression vulgarisée pourrait être POMM: "Principes pour déterminer Où Mettre une Méthode."

En tant qu'ingénieur logiciel ou ingénieure logiciel, vous devez souvent décider où placer une méthode (dans quelle classe), et cette décision ne devrait pas être prise de manière arbitraire, mais plutôt en suivant les directives d'ingénierie favorisant la modularité.

Alors, les GRASP sont les directives qui vous aident à prendre des décisions de conception, menant à un design avec moins de couplage inutile et avec des classes plus cohésives. Les classes cohésives sont plus faciles à comprendre, à maintenir et à réutiliser.

::: {.callout-tip appearance="minimal"}
{{< fa solid hat-cowboy-side >}} Avez-vous déjà une bonne expérience en programmation?
Avez-vous l'habitude de coder rapidement des solutions qui fonctionnent?
Si la réponse est oui, alors travailler avec les principes GRASP peut être un défi pour vous.
Dans la méthodologie enseignée dans ce manuel, vous devez être en mesure de justifier vos choix de conception, et cela va vous ralentir au début (réflexe du "hacking cowboy" peut-être?).
Le but avec les principes GRASP est de (ré)apprendre à faire du code qui fonctionne, mais qui est également facile à maintenir.
C'est normal au début que ça prenne plus de temps, car il faut réfléchir pour appliquer les principes.
Une fois que vous aurez l'habitude d'utiliser les GRASP, vous serez encore rapide avec votre développement, mais, en plus, votre design sera meilleur sur le plan de la maintenabilité, et vous aurez plus de confiance dans vos choix.
:::

## Spectre de la conception {#sec-SpectreDeLaConception}

Neal Ford [-@Ford2009] a [proposé](https://www.ibm.com/developerworks/library/j-eaed1/index.html) la notion d'effort pour la conception qu'il a nommée le "Spectre de la conception". La @fig-SpectreConception illustre le principe.

``` {#fig-SpectreConception .plantuml caption="Spectre de la conception [@Ford2009]."}
@startuml
!include ecriture.pumlinclude
scale 1.2
skinparam classBorderColor hidden
skinparam classBackgroundColor hidden
skinparam classArrowColor black
hide stereotypes
hide empty members
class "<size:30>[" as hacking
class "« Hacking cowboy »" as Nh
class "**+**" as agile <<middle>>
class "            Agile          " as Na
class "<size:30>]" as waterfall
class "« Cascade pure »" as Ncp

hacking -right[bold]- agile
agile -right[bold]- waterfall

waterfall <-u[dashed]- Ncp
agile <-u[dashed]- Na
hacking <-d[dashed]- Nh
@enduml
```

À une extrémité, il y a la mentalité de mettre presque zéro effort pour une conception, que l'on nomme "hacking cowboy".
C'est le cas d'un hackathon (un marathon de programmation durant 24 ou 48 heures où il faut produire une solution rapidement), au cours duquel vous ne feriez pas un logiciel avec 10 patterns GoF et vous ne feriez pas non plus les diagrammes UML pour réfléchir à votre architecture.
Vous savez aussi que le code produit lors d'un hackathon ne sera pas facile à maintenir.
Le seul but de cette activité est de développer du code qui marche pour montrer une idée intéressante.

Une situation similaire s'applique à certains contextes d'entreprise, par exemple une entreprise en démarrage qui a seulement un financement pour six mois.
Si une solution de ["produit minimum viable" (MVP en anglais)](https://en.wikipedia.org/wiki/Minimum_viable_product) {{< fa brands wikipedia-w >}} n'existe pas à la fin de la période de financement, l'entreprise n'existera plus, car il n'y aura pas une seconde période de financement.
Si, par contre, l'entreprise est financée pour une seconde période, la conception du code pourrait avoir besoin de beaucoup de soin et de maintenance, car elle aura été préalablement négligée.
Cette négligence de la conception (pour la maintenabilité) est aussi nommée la [dette technique](#sec-DetteTechnique).

À l'autre extrémité du spectre de la conception, on retrouve ce que l'on nomme "Cascade pure", où beaucoup d'effort a été déployé pour la conception.
Dans le cycle de vie en cascade, on met un temps fixe (par exemple plusieurs mois) à étudier la conception.
Comme toute chose poussée à l'extrême, ce n'est pas idéal non plus. Dans son livre, @craig_uml_2005 explique en détail des problèmes posés par une approche en cascade.
En dépit des problèmes dus à l'approche en cascade, elle est encore utilisée dans certains domaines, par exemple les logiciels pour le contrôle d'avions ou le contrôle d'appareils médicaux.
La sécurité et la robustesse des logiciels sont très importantes, alors on passe beaucoup de temps à vérifier et à valider la conception.
Puisque les exigences sont plus stables (et que les développeurs et les développeuses ont *a priori* une meilleure compréhension du domaine), l'approche en cascade n'est pas si mal. 
Pourtant, le coût pour produire des logiciels certifiés est énorme.

Le spectre de la conception est très important pour le monde réel, parce qu'une ingénieure ou un ingénieur devrait pouvoir s'adapter selon les attentes de son travail.
Le dogme sur "la bonne manière" de développer un logiciel est souvent sans contexte. 
C'est le contexte de l'entreprise pour laquelle vous travaillez qui peut quantifier les efforts à mettre sur la conception.
Cependant, méfiez-vous des entreprises qui ne portent aucune attention à la conception (l'extrémité "hacking cowboy" du spectre), même si l'on vous dit que c'est "agile".
<!-- Si vous négligez complètement la conception, vous pouvez peut-être produire du code qui fonctionne plus vite à court terme.
Mais il faudra repayer la dette technique un jour.
Un moyen de gérer cette dette technique est de *réusiner* (anglais refactor). -->

\newpage

## Tableau des principes GRASP {#tbl-GRASPTable}

Voici un extrait du livre de @craig_uml_2005.

<!-- Attention: le tableau suivant a été généré avec l'éditeur "Visual" de RStudio -->

+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Pattern                                                  | Description                                                                                                                                                                                                                                                   |
+:=========================================================+:==============================================================================================================================================================================================================================================================+
| Expert en information\                                   | Un principe général de conception d'objets et d'affectation des responsabilités.\newline                                                                                                                                                                      |
| *F16.11/A17.11*\ {{< fa solid book >}}                   |                                                                                                                                                                                                                                                               |
|                                                          | Affectez une responsabilité à l'expert -- la classe qui possède les informations nécessaires pour s'en acquitter.\newline                                                                                                                                     |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Créateur\                                                | Qui crée? (Notez que Fabrique Concrète est une solution de rechange courante.)\newline                                                                                                                                                                        |
| *F16.10/A17.10*\ {{< fa solid book >}}                   |                                                                                                                                                                                                                                                               |
|                                                          | Affectez à la classe B la responsabilité de créer une instance de la classe A si l'une des assertions suivantes est vraie:                                                                                                                                    |
|                                                          |                                                                                                                                                                                                                                                               |
|                                                          | 1.  B contient A                                                                                                                                                                                                                                              |
|                                                          | 2.  B agrège A \[à favoriser\]                                                                                                                                                                                                                                |
|                                                          | 3.  B a les données pour initialiser A                                                                                                                                                                                                                        |
|                                                          | 4.  B enregistre A                                                                                                                                                                                                                                            |
|                                                          | 5.  B utilise étroitement A\newline                                                                                                                                                                                                                           |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Contrôleur\                                              | Quel est le premier objet en dehors de la couche présentation qui reçoit et coordonne ("contrôle") les opérations système?\newline                                                                                                                            |
| *F16.13/A17.13*\ {{< fa solid book >}}                   |                                                                                                                                                                                                                                                               |
|                                                          | Affectez une responsabilité à la classe qui correspond à l'une de ces définitions:                                                                                                                                                                            |
|                                                          |                                                                                                                                                                                                                                                               |
|                                                          | 1.  \[Contrôleur de façade\] [Cette classe] représente le système global, un "objet racine", un équipement ou un sous-système (contrôleur de façade).                                                                                                         |
|                                                          | 2.  \[Contrôleur de session\] [Cette classe] représente un scénario de cas d'utilisation dans lequel l'opération système se produit (*contrôleur de session* ou contrôleur de cas d'utilisation). \[On la nomme GestionnaireX, où X est le nom du cas         |
|                                                          | d'utilisation.]\newline                                                                                                                                                                                                                                       |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Faible Couplage\                                         | Comment minimiser les dépendances?\newline                                                                                                                                                                                                                    |
| (évaluation)\                                            |                                                                                                                                                                                                                                                               |
| *F16.12/A17.12*\ {{< fa solid book >}}                   | Affectez les responsabilités de sorte que le couplage (inutile) demeure faible. Employez ce principe pour évaluer les alternatives.\newline                                                                                                                   |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Forte Cohésion\                                          | Comment conserver les objets cohésifs, compréhensibles, gérables et, en conséquence, obtenir un Faible Couplage?\newline                                                                                                                                      |
| (évaluation)\                                            |                                                                                                                                                                                                                                                               |
| *F16.14/A17.14*\ {{< fa solid book >}}                   | Affectez les responsabilités de sorte que les classes demeurent cohésives. Employez ce principe pour évaluer les différentes solutions.\newline                                                                                                               |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Polymorphisme\                                           | Qui est responsable quand le comportement varie selon le type?\newline                                                                                                                                                                                        |
| *F22.1/A25.1*\ {{< fa solid book >}}                     |                                                                                                                                                                                                                                                               |
|                                                          | Lorsqu'un comportement varie selon le type (classe), affectez la responsabilité de ce comportement -- avec des opérations polymorphes -- aux types selon lesquels le comportement varie.\newline                                                              |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Fabrication Pure *F22.2/A25.2*\ {{< fa solid book >}}    | En cas de situation désespérée, que faire quand vous ne voulez pas transgresser les principes de Faible Couplage et de Forte Cohésion?\newline                                                                                                                |
|                                                          |                                                                                                                                                                                                                                                               |
|                                                          | Affectez un ensemble très cohésif de responsabilités à une classe "comportementale" artificielle qui ne représente pas un concept du domaine --- une entité fabriquée pour augmenter la cohésion, diminuer le couplage et faciliter la réutilisation.\newline |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Indirection\                                             | Comment affecter les responsabilités pour éviter le couplage direct?\newline                                                                                                                                                                                  |
| *F22.3/A25.3*\ {{< fa solid book >}}                     |                                                                                                                                                                                                                                                               |
|                                                          | Affectez la responsabilité à un objet qui sert d'intermédiaire avec les autres composants ou services.\newline                                                                                                                                                |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Protection des variations\                               | Comment affecter les responsabilités aux objets, sous-systèmes et systèmes de sorte que les variations ou l'instabilité de ces éléments n'aient pas d'impact négatif sur les autres?\newline                                                                  |
| *F22.4/A25.4*\ {{< fa solid book >}}                     |                                                                                                                                                                                                                                                               |
|                                                          | Identifiez les points de variation ou d'instabilité prévisibles et affectez les responsabilités afin de créer une "interface" stable autour d'eux.                                                                                                            |
+----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

: Patterns (principes) GRASP {#tbl-tableGRASP tbl-colwidths=\[25,75\]}

## GRASP et RDCU

Les principes GRASP sont utilisés dans les réalisations de cas d'utilisation (RDCU). On s'en sert pour annoter les décisions de conception, pour rendre explicites (documenter) les choix. Voir la section [Réalisations de cas d'utilisation (RDCU)](#sec-rdcu) pour plus d'informations.

## GRASP et patterns GoF

On peut voir les principes GRASP comme des généralisations (principes de base) des patterns GoF. Voir la section [Décortiquer les patterns GoF avec GRASP](#sec-GRASP-GoF) pour plus d'informations.

## Exercices

::: {#exr-GRASP_GOF_polymorphisme}

### GRASP Polymorphisme

Soit le diagramme de classe sur la @fig-GRASP_polymorphisme_ex modélisant l'exemple de @Fowl18a à [*Replace Conditional with Polymorphism*](https://refactoring.com/catalog/replaceConditionalWithPolymorphism.html).

```{.plantuml #fig-GRASP_polymorphisme_ex caption='Classe "Bird" à laquelle on peut appliquer le principe GRASP Polymorphisme.'}
@startuml
!include normal.pumlinclude
class Bird {
    type : String
    numberOfCoconuts : number
    voltage : number

    getPlumage() : String
}
@enduml
```

Appliquez le GRASP Polymorphisme pour le code suivant:

```javascript
get plumage() {
    switch (this.type) {
        case 'EuropeanSwallow':
            return "average";
        
        case 'AfricanSwallow':
            return (this.numberOfCoconuts > 2) ? "tired" : "average";
        
        case 'NorwegianBlueParrot':
            return (this.voltage > 100) ? "scorched" : "beautiful";
        
        default:
            return "unknown";
    }
}
```

:::

<!-- ::: {#exr-GRASP_GOF_cohesion}

### GRASP Cohésion

Cet exercice est inspiré d'un exemple donné dans le livre *Head First Design Patterns* de @FreemanBatesSierraRobson200410.

- Quelles classes sur la @fig-GRASP_cohesion_ex1 ont de multiples responsabilités?
- Déterminez si les classes sur la @fig-GRASP_cohesion_ex2 ont une cohésion forte ou faible.

```{.plantuml #fig-GRASP_cohesion_ex1 caption="Quelles classes ont de multiples responsabilités?"}
@startuml
!include normal.pumlinclude
class Jeu {
    login()
    inscrire()
    déplacer()
    tirer()
    rester()
}

class Joueur {
    setNom()
    setAdresse()
    setNuméroTéléphone()
    sauvegarder()
    charger()
}

class Téléphone {
    composer()
    raccrocher()
    parler()
    envoyerDonnées()
    flash()
}

class JeuCartes {
    hasNext()
    next()
    remove()
    addCard()
    removeCard()
    shuffle()
}

class Panier {
    ajouter()
    enlever()
    encaisser()
    sauvegarder()
}

class Iterator {
    hasNext()
    next()
    remove()
}

@enduml
```

```{.plantuml #fig-GRASP_cohesion_ex2 caption="Quelles classes ont une cohésion forte? Une cohésion faible?"}
@startuml
!include normal.pumlinclude
class Jeu {
    login()
    inscrire()
    déplacer()
    tirer()
    rester()
    getMeilleureScore()
    getNom()
}

class SessionPartie {
    login()
    inscrire()
}

class ActionsJoueur {
    déplacer()
    tirer()
    rester()
}

class Joueur {
    getMeilleurScore()
    getNom()
}

@enduml
```

::: -->

::: {#exr-GRASP_GOF_contrôleur}

### GRASP Contrôleur et Fabrication Pure

- Expliquez pourquoi le principe du GRASP Contrôleur dans le cas d'un contrôleur de session (de cas d'utilisation) est une Fabrication Pure.
- Soit un contrôleur de session `GestionnaireVentes`; quelle est la "situation désespérée" qui est mitigée par ce contrôleur? Astuce: relire la définition de Fabrication Pure.

:::

::: {#exr-GRASP_GOF_expert}

### GRASP Expert en information et Forte cohésion

Appliquez le GRASP Expert en information pour améliorer la conception des classes dans le code suivant:

```javascript
class Point {
    x:number;
    y:number;

    constructor(x:number, y:number) {
        this.x = x;
        this.y = y;
    }
}

class Circle {
    center:Point;
    radius:number;

    constructor(center:Point, radius:number) {
        this.center = center;
        this.radius = radius
    }
}

class SomeClass {
    someMethod() {
        const center = new Point(0, 12);
        const c = new Circle(center, 14);
        
        const area = Math.PI * c.radius* c.radius;
        const diameter = c.radius * 2;
        const circumference = Math.PI * c.radius * 2;
    }
}
```

:::: {.callout-note collapse="true" icon="false"}

## Voici une solution

Puisque la classe `Circle` possède les informations nécessaires (`radius`) pour calculer `area`, `diameter` et `circumference`, c'est elle qui doit contenir les méthodes pour calculer ces propriétés.
Cela augmente la cohésion de la classe `SomeClass` puisqu'elle a moins de responsabilités.
La complétude de la classe `Circle` est améliorée et ses méthodes peuvent être testées et réutilisées dans d'autres classes.

Pour être concis, la classe `Point` est omise puisqu'aucune modification n'y est apportée.

```javascript
class Circle {
    center:Point;
    radius:number;

    constructor(center:Point, radius:number) {
        this.center = center;
        this.radius = radius
    }

    get area():number {
        return Math.PI * this.radius * this.radius;
    }

    get diameter():number {
        return this.radius * 2;
    }

    get circumference():number {
        return Math.PI * this.radius * 2;
    }
}

class SomeClass {
    someMethod() {
        const center = new Point(0, 12);
        const c = new Circle(center, 14);
        
        const area = c.area;
        const diameter = c.diameter;
        const circumference = c.circumference;
    }
}
```
::::

:::

